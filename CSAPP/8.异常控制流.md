#异常控制流
 从给处理器加电开始,直到断电,程序计数器假设一个值的序列a0,a1,a2...,an-1  
 其中,每个a<sub>k</sub>是某个对应的指令I<sub>k</sub>的地址.每次从a<sub>k</sub>到a<sub>k+1</sub>的过度称为**控制转移(control transfer)**.这样的控制转移序列叫做处理器的**控制流(control flow)**.  
 现代系统通过使用控制流发生突变来对这些情况作出反应.一般把这些突变称为**异常控制流(Exceptional Control Flow,ECF)**.异常控制流发生在计算机系统的各个层次.  
 在硬件层,硬件检查侧到的事件会出发控制突然转移到异常处理程序.  
 在操作系统层,内核通过上下文切换将控制从一个用户进程转移到另一个用户进程.  
 在应用层,一个进程可以发送**信号**到另一个进程,而接受者会将控制突然转移到它的一个信号处理程序.一个程序可以通常回避通常的栈规则,并执行到其他函数中任意位置的非本地跳转来对错误作出反应.  
 理解ECF的原因:  
 + 帮助你理解重要的系统概念. ECF是操作系统用来实现I/O,进程和虚拟内存的基本机制.  
 + 帮助你理解应用程序是如何与操作系统交互的. 应用程序通过使用一个叫做陷阱(trap)或者系统调用(system call)的ECF形式,向操作系统请求服务.比如,向磁盘写数据,从网络读数据,创建一个新进程,以及终止当前进程.都是通过应用程序调用系统调用来实现的.  
 + 帮助你理解并发. ECF是计算机系统中实现并发的基本机制.在运行的并发的例子有: 中断应用程序执行的异常处理程序,在时间上重叠执行的进程和线程,以及中断应用程序执行的信号处理程序.  
 + 帮助你理解软件异常如何工作. 像c++和 Java这样的语言通过 try-catch 以及 throw 语句来提供软件异常机制.软件异常允许程序进行非本地跳转(违反通常的调用/返回栈规则的跳转)来相应错误情况.非本地跳转是一种应用层ECF.  

本章的重要性在于将开始学习应用是如何与操作系统交互的.这些交互都是围绕着ECF的.  
将描述存在于计算机系统中所有层次上的各种形式的ECF.从异常开始,异常位于硬件和操作系统交界的部分.  
还会讨论系统调用,它们为应用程序提供到操作系统的入口点的异常.  
然后会提升抽象的层次,描述进程和信号,它们位于应用和操作系统的交界之处.  
##8.1 异常
 **异常(exception)**就是控制流中的突变,来响应处理器状态的某些变化.当处理器状态中发生一个重要变化时,处理器正在执行某个当前指令I<sub>curr</sub>.在处理器中,状态被编码为不同的位和信号.状态变化称为事件(event).事件可能和当前指令的执行直接相关.比如,发生虚拟内存缺页,算法溢出,或者一条指令试图除以零.另一方面,事件也可能和当前指令的执行没有关系.比如,一个系统定时器产生信号或者一个I/O请求完成.  
 在任何情况下,当处理器检测到有事件发生时,就会通过一张叫做异常表(exception table)的跳转表,进行一个简洁过程调用(异常),到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handler)).当异常处理程序完成处理后,根据引起异常的事件类型,会发生以下3种情况中的一种:  
 + 处理程序将控制返回给当前指令,即当时间发生时正在执行的指令.  
 + 处理程序将控制返回给I next,如果没有发生异常将会执行下一条指令.  
 + 处理程序终止被中断的程序.  

###8.1.1 异常处理
 系统中可能的美中类型的异常都分配了一个唯一的非负整数的**异常号(exception number)**.其中一些号码是由处理器的设计者分配的,其他号码是由操作系统内核(操作系统常驻内存的部分)的设计者分配的.前者的示例包括被零除,缺页,内存访问违例,断点以及算术运算溢出.后者的示例包括系统调用和来自外部I/O设备的信号.  
 在系统启动时,操作系统分配和初始化一张称为**异常表**的跳转表,使得表木k包含异常k的处理程序的地址.  
 运行时(系统在执行某个程序时),处理器检测到发生了一个事件,并且确定了相应的异常号k.随后,处理器出发异常,方法是执行间接过程调用,通过异常表的表目k,转到相应的处理程序.异常号是到异常表中的索引,异常表的起始地址放在一个叫做**异常表基址寄存器**的特殊CPU寄存器里.  
 异常类似于过程调用,但是有一些重要的不同之处:  
 + 过程调用时,在跳转到处理程序之前,处理器将返回地址压入栈中.然而,根据异常的类型,返回地址要么是当前指令(当事件发生时正在执行的指令),要么是下一条指令(如果事件不发生,将会在当前指令后执行的指令).  
 + 处理器也把一些额外的处理器状态压入到栈里,在处理程序返回时,重新开始执行被中断的程序会需要这些状态.  
 + 如果控制从用户程序转移到内核,所有这些项目都被压入到内核栈中,而不是压到用户栈中.  
 + 异常处理程序运行在内核模式下,意味着它们对所有的系统资源都有完全的访问权限.  
  
  
一旦硬件出发了异常,剩下的工作就是由异常处理程序在软件中完成.处理程序处理完事件后,通过执行一条特殊的"从中断返回"指令,可选地返回到被中断的程序,该指令讲适当的状态弹回到处理器的控制和数据寄存器中,如果异常中断的是一个用户程序,就将恢复为用户模式,然后将控制返回给被中断的程序.  
###8.1.2 异常的类别
 异常可以分为四类: 中断(interrupt),陷阱(trap),故障(fault),终止(abort).  

类别 | 原因             |异步/同步 | 返回行为
---- | ---             | ------   | -------
中断 | 来自I/O设备的信号 | 异步     | 总是返回到下一条指令
陷阱 | 有意的异常        | 同步    | 总是返回到下一条指令
故障 | 潜在可恢复的错误  | 同步     | 可能返回到当前指令
终止 | 不可恢复的错误    | 同步     | 不会返回
 **1.中断**  
 中断是**异步**发生的,是来自处理器外部的I/O设备的信号的结果.硬件中断不是由任何一条专门的指令造成的,从这个意义上来说它是异步的.一件中断的异常处理程序常常称为**中断处理程序(intgterrupt handler).**  
 在当前指令完成执行之后,处理器注意到中断引脚的电压变高了,就从系统总线读取异常号,然后调用适当的中断处理程序.当处理程序返回时,它就将控制返回给下一条指令(也就是没有发生中断,在控制流中会在当前指令之后的那条指令).结果是程序继续执行,就好像没有发生中断一样.  
 剩下的异常类型是同步发生的,是执行当前指令的结果.把这类指令叫做故障指令(faulting instruction).  
 **2.陷阱和系统调用**  
 陷阱是**有意**的异常,是执行一条指令的结果.就像中断处理程序一样,陷阱处理程序将控制返回到下一条指令.陷阱最重要的用途是在用户程序和内核之间提供了一个像过程一样的接口,叫做系统调用.  
 用户程序进场需要向内核请求服务,比如读一个文件,创建一个新的进程,加载一个新的程序,或者终止当前京城.为了允许对这些内核服务的受控访问,处理器提供了一条特殊的syscall n 指令,当用户程序想要请求服务n时,可以执行这条指令.执行syscall指令会导致一个到异常处理程序的陷阱,这个处理程序解析参数,并调用适当的内核程序.  
 从程序员的角度看,系统嗲用和普通的函数调用时一样的,然而,它们的实现非常不同,普通的函数运行在**用户模式**中,用户模式限制了函数可以执行的指令的类型,而且它们只能访问与调用函数相同的栈.系统调用运行在**内核模式**中,内核模式允许系统调用执行特权指令,并访问定义在内核中的栈.  
 **3.故障**  
 故障由错误情况引起,它可能能够被故障处理程序修正.当故障发生,处理器将控制转移给故障处理程序.如果处理程序能够修正这个错误情况,就将控制返回到引起故障的指令,从而重新执行它.否则,处理程序返回到内核中的abort例程,abort会终止引起故障的应用程序.  
 一个景点的故障示例是缺页异常,当指令引用一个虚拟地址,而与该地址相对应的物理页面不存在内存中,因此必须从磁盘中取出时,就会发生故障.  
 **4.终止**  
 终止是不可恢复的致命错误造成的结果,通常是一些硬件错误,比如DRAM或者SRAM位被损坏时发生的奇偶错误.终止处理程序从不讲控制返回给应用程序.处理程序将控制返回给一个abort,从而终止这个应用程序.  
 
##8.2进程  
 异常是允许操作系统内核提供**进程**概念的基本构造快.  
 进程的经典定义就是一个执行中程序的实例.系统中的每个程序都运行在某个进程的上下文(context)中.上下文是由程序正确运行所需的状态组成的.这个状态包括存放在内存中的程序的代码和数据,它的栈,通用目的寄存器的内容,程序计数器,环境变量以及打开文件描述符的集合.  
 每次用户通过向shell输入一个可执行目标文件的名字,运行程序时,shell就会创建一个新的进程,然后在这个新进程的上下文中运行这个可执行目标文件.**应用程序也能够创建新进程**,并且在这个新进程的上下文中运行它们自己的代码和其他应用程序.  
 进程提供给应用程序的关键抽象:  
 + 一个独立的逻辑控制流,它提供了一个假象,好像我们的程序独占地使用处理器.  
 + 一个私有的地址空间,它提供一个假象,好像我们的程序独占地使用内存系统.  
  
###8.2.1 逻辑控制流
 即使在系统中通常有许多其他程序在运行,进程也可以向每个程序提供一种假象,好像它在独占地使用处理器.如果想用调试器单步执行程序,可以看到一系列的程序计数器的值,这些值唯一地对应于包含在程序的可执行目标文件中的指令,或是包含在运行时动态链接到程序的共享对象中的指令.这个PC值的序列叫做**逻辑控制流**,或者简称**逻辑流**  
 进程是轮流使用处理器的,每个进程执行它的流的一部分,然后被抢占(暂时挂起),然后轮到其他进程.  
###8.2.2 并发流
 计算机系统中逻辑刘有许多不同的形式.异常处理程序,进程,信号处理程序,线程和JAVA进程都是逻辑流的例子.  
 一个逻辑流的执行在**时间上**与另一个流重叠,称为并发流(concurrent flow),这两个流称为**并发**地运行.  
 多个流并发地执行的一般现象被称为并发.一个进程和其他进程轮流运行的概念称为**多任务(multitasking)**.一个进程执行它的控制流的一部分的每一时间段叫做时间片.因此,多任务也叫作时间分片.  
 并发流的思想与流运行的处理器核数和计算机数无关,如果两个流在时间上重叠,那么它们就是并发的.即使它们是运行在同一个处理器上.**并行流**是并发流的一个真子集.如果两个流并发地运行在不同的处理器核或者计算机上,那么我们称它们为并行流,它们并行地运行,且并行地执行.  
###8.2.3 私有地址空间
 进程也为每个程序提供一种假象,好像它独占地使用系统地址空间.在一台n位地址的机器上,地址空间是 2<sup>n</sup>个可能地址的集合,0,1,..,2 n -1.进程位每个程序提供它自己的私有地址空间.和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的,从这个意义上说,这个地址空间是私有的.  
###8.2.4 用户模式和内核模式
 处理器提供一种机制,限制一个应用可以执行的指令以及它可以访问的地址空间范围.  
 处理器通常是用某个控制寄存器中的一个模式位(mode bit)来提供这种功能的,该寄存器描述了进程当前享有的特权.当设置了模式位时,进程就运行在内核模式中.一个运行在内核模式的进程可以执行指令集中的任何指令,并且可以访问系统中的任何内存位置.  
 没有设置模式位时,进程就运行在用户模式中.用户模式的进程不允许执行特权指令,任何这样的尝试都会导致致命的保护故障.用户程序必须通过系统调用接口间接地访问内核代码和数据.  
 运行应用程序代码的进程初始时是在用户模式中,进程从用户模式变为内核模式的唯一方法是通过如中断,故障或者陷入系统调用这样的异常.当异常发生时,控制传递到异常处理程序,处理器将模式从用户模式变为内核模式.处理程序运行在内核模式中,当它返回到应用程序代码时,处理器就把模式从内核模式改回到用户模式.  
###8.2.5 上下文切换
 操作系统内核使用一种称为上下文切换(context switch)的较高层形式的异常控制流来实现多任务.  
 内核位每个进程维持一个上下文.上下文就是内核重新启动一个被抢占的进程所需要的状态.  
 在进程执行的某些时刻,内核可以决定枪战当前进程,并重新开始一个先前被枪战了的进程.泽中决策叫做调度,是由内核调度了这个进程.在内核调度了一个新的进程运行后,它就抢占当前进程,并使用一种称为上下文切换的机制来将控制转移到新的进程.  
 上下文切换:  
 保存当前进程的上下文.  
 恢复某个先前被抢占的进程被保存的上下文.  
 将控制传递给这个新恢复的进程.  
 当内核代表用户执行系统调用时,可能会发生上下文切换.如果系统调用因为等待某个时间发生而阻塞,俺么内核可以让当前线程休眠,切换到另一个进程.  
 中断也可能引发上下文切换.每次发生定时器中断时,内核就能判定当前进程已经运行了足够长的时间,并切换到一个新进程.  
 进程A初始运行在用户模式中,知道它通过**执行系统调用read**陷入到内核.内核中的陷阱处理程序请求来自磁盘控制器的DMA传输,并且安排在磁盘控制器完成从磁盘到内存的数据传输后,磁盘中断处理器.  
 磁盘取数据要用一段相对较长的世界,所以内核执行从进程A到进程B的上下文切换,而不是在这个间歇时间内等待,什么也不做.注意在切换之前,内核正代表进程A在用户模式下执行指令(即没有单独的内核进程).在切换的第一部分中,内核代表进程A在内核模式下执行指令.然后在某一时刻,它开始代表进程B(仍然是内核模式下)执行指令.在切换之后,内核代表进程B在用户模式下执行指令.  
 随后,进程B在用户模式下运行一会儿,直到磁盘发出一个中断信号,表示数据已经从磁盘传送到了内存.内核判定进程B已经运行了足够长的时间,就执行一个从进程B到进程A的上下文切换,将控制返回给进程A中紧随在**系统调用read之后**的那条指令.进程A继续运行,直到下一次异常发生.以此类推.  
##8.4进程控制
 每个进程都有一个唯一的正数(非0)进程ID(PID).  
 从程序员的角度,可以认为进程总是处于下面三种状态之一:  
 + 运行.进程要么在CPU上执行,要么在等待被执行且最终会被内核调度.  
 + 停止.进程的执行要被挂起,且不会被调度.当收到SIGSTOP,SIGTSTP,SIGTTIN或者SIGTTOU信号时,进程就停止,并且保持停止直到它收到一个SIGCONT信号,这个时刻,进程在此开始运行.(信号时一种软件中断的)
 + 终止.进程永远地停止了.今晨会因为三种原因终止.1)收到一个信号,该信号默认行为是终止进程. 2)从主程序返回. 3)调用exit函数.  
  
父进程通过调用fork函数创建一个新的运行的子进程.  
 新创建的子进程几乎但不完全与父进程相同.子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本,包括代码和数据点,堆,共享库以及用户栈.子进程还获得与父进程任何打开文件描述符相同的副本,这就意味着当父进程调用fork时,子进程可以读写父进程中打开的任何文件.父进程和新创建的子进程之间最大的却别在于它们有不同的PID.  
 fork函数只会被调用一次,却会返回两次:一次是在调用进程(父进程)中,一次是在新创建的子进程中.父进程中,fork返回子进程的PID.在子进程中,fork返回0.因为子进程的PID总是为非零,返回值就提供了一个明确的方法来分辨程序时在父进程还是在子进程中执行.  
```
int main()
{
	pid_t pid;
	int x = 1;
	
	pid = Fork();   //Fork为包装函数,被封装了,大致看懂就可以了	
	if(pid == 0) {
		printf("child : x= %d\n", ++x);
		exit(0);
	}
	
		
	printf("parent: x=%d\n", --x);
	exit(0);
}
输出:
parent: x=0
child : x=2
```
 + 调用一次,返回两次.fork函数被父进程调用一次,但是返回两次.一次返回到父进程,一次返回到新创建的子进程.  
 + 并发执行.父进程和子进程是并发运行的独立进程.内核能够以任意方式交替执行它们的逻辑控制流中的指令.输出语句的顺序是随机的,不分先后.  
 + 相同但是独立的地址空间. 如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程,会看到两个进程的地址空间都是相同的.每个进程有相同的用户栈,相同的本地变量值,相同的堆和相同的全局变量值,以及相同的代码.因此,当fork函数在第六行返回时,本地变量x在父进程和子进程中都为1.然而,因为父进程和子进程是独立的进程,它们都有自己的私有地址空间.后面,父进程和子进程对x所做的任何改变都是独立的,不会反应在另一个进程的内存中.  
 + 共享文件.当运行这个示例程序时,注意到父进程和子进程都把它们的输出现实在屏幕上.原因是子进程继承了父进程所有的打开文件.当父进程调用fork时,stdout文件时打开的,指向屏幕.子进程集成了这个文件,因此它的输出也是指向屏幕的.  
###8.4.3 回收子进程
 当一个进程由于某种原因终止时,内核并不是立即把它从系统中清楚.相反,进程被保持在一种已终止的状态中,直到被它的父进程回收.当父进程回收以终止的子进程时,内核将子进程的推出状态传递给父进程,然后抛弃已终止的进程,从此时开始,该进程就不存在了.一个终止了但还未被回收的进程称为僵死进程.  
 如果一个父进程终止了,内核会安排init进程称为它的孤儿进程的养父.init进程的PID位1,是在系统启动时由内核创建的,它不会终止,是所有进程的祖先.如果父进程没有回收它的僵死子进程就终止了,内核会安排init进程去回收它们.不过长时间运行的程序,比如shell或者服务器,总是应该回收它们的僵死子进程.即使僵死子进程没有运行,它们仍然消耗系统的内存资源.  
 进程可以通过调用waitpid函数来等待他的子进程终止或者停止.  
 waitpid挂起调用进程的执行,直到它的等待集合中的一个子进程终止.如果等待集合中的一个进程在刚调用的时候就已经终止了,那么waitpid就立即返回.在这两种情况中,waitpid返回导致waitpid返回的已终止子进程的PID.此时,已终止的子进程已经被回收,内核会从系统中删除它的所有痕迹.  
 程序不会按照特定的顺序回收子进程.子进程回收的顺序是这台特定的计算机系统的属性,在另一个系统,甚至在同一个系统上在此执行一次,两个子进程都可能以相反的顺序被回收.这是非确定性行为的一个示例.  
***
 **程序和进程**  
 程序和进程之间的区别.程序时一堆代码和数据;程序可以作为目标文件存在磁盘上,或者作为段存在于地址空间中.  
 进程是执行中程序的一个具体的实例;程序总是运行在某个进程的上下文中.  
 fork函数在新的子进程中运行相同的程序,新的子进程是父进程的一个复制品.  
 execve函数在当前进程的上下文加载并运行一个新的程序.它会覆盖当前进程的地址空间.并没有创建一个新的进程.  
 新的进程仍然有相同的PID,并且集成了调用execve函数时已打开的所有文件描述符.  
##8.5 信号
 Linux信号,它允许进程和内核中断其他进程,是一种更高层的软件形式的异常.  
 一个**信号**就是一条小消息,它通知进程系统中发生了一个某种类型的时间.  
 美中信号类型都对应于某种系统时间.低层的硬件异常是由内核异常处理程序处理的,正常情况下,对用户进程是不可见的.信号提供了一种机制,通知用户进程发生了这些异常.比如,如果一个进程试图除以0,那么内核就发送给它一个SIGFPE信号.如果一个进程执行一条非法指令,那么内核就发送给它一个SIGILL信号.  
###8.5.1 信号术语
 传送一个信号到目的进程是由两个不同步骤组成的:  
 + 发送信号.内核通过更新目的进程上下文中的某个状态,发送一个信号给目的进程.发送信号可以有如下两种原因: 1) 内核检测到一个系统时间,比如除零错误或者子进程终止. 2) 一个进程调用了kill函数,显示的要求内核发送一个信号给目的进程.一个进程可以发送信号给它自己.  
 + 接受信号.当目的进程被内核强迫以某种方式对信号的发送做出反应时,它就接收了这个信号.进程可以忽略这个信号,终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号.  
一个发出而没有被接收的信号叫做**待处理信号(pending signal)**.在任何时刻,一种类型至多只会有一个待处理信号.如果一个进程有一个类型为k的待处理信号,那么任何解析拉哎发送到这个进程的类型为k的信号都不会排队等待;它们只是被简单地丢弃.一个进程可以有选择性地**阻塞**接收某种信号.当一种信号被阻塞时,它扔可以呗发送,但是产生的待处理信号不会被接收,直到进程取消对这种信号的阻塞.  一个待处理信号最多只能被接收一次.内核位每个进程在pending位向量中维护者待处理信号的集合,而在blocked位向量中维护者被阻塞的信号集合.只要传送了一个类型为k的信号,内核就会设置pending中的第k位,而只要接收了一个类型为k的信号,内核就会清楚pending中的第k位.  
###8.5.3 接收信号
 当内核吧进程p从内核模式切换到用户模式时(例如,从系统调用返回或是完成了一次上下文切换),它会检查进程p的未被阻塞的待处理信号的集合.如果这个集合为空,那么内核将控制就传递回p的逻辑控制流中的下一条指令.如果集合是非空的,那么内核选择集合中的某个信号k(通常是最小),并且强制p接收信号k.收到这个信号会出发进程采取某种行为.一旦进程完成了这个行为,那么控制就传递回p的逻辑控制流中的下一条指令.每个信号类型都有一个预定义的默认行为,是下面的一种:  
 + 进程终止.  
 + 进程终止并转储内存。  
 + 进程停止（挂起）直到被SIGCONT信号重启.  
 + 进程忽略该信号.  
###8.5.4 阻塞和解除阻塞信号
 信号处理是Linux系统编程最棘手的一个问题.处理程序有几个属性使得它们很难推理分析: 1) 处理程序与主程序并发运行,共享同样的全局变量,因此可能与主程序和其他处理程序互相干扰; 2) 如何以及何时接收信号的规则常常有违人的直觉; 3) 不同的系统有不同的信号处理语义.  
 **1. 安全的信号处理**  
 信号处理程序很麻烦是因为它们和主程序以及其他信号处理程序并发地运行.如果处理程序和主程序并发地访问通用的全局数据结构,结果可能会不可预知,而且经常是致命的.  
 
 + **处理程序要尽可能简单.避免麻烦的最好方法是保持处理程序尽可能小和简单.**  
 + **在处理程序中只调用异步信号安全的函数.**所谓**异步信号安全**的函数能够被信号处理程序安全的调用.要么它是可重入的.要么它不能被信号处理程序中断.  
 + **保存和恢复errno.**许多Linux异步安全的函数都会在出错返回时设置errno.在处理程序中调用这样的函数可能会干扰主程序中其他依赖于errno的部分.解决方法是在进入处理程序时吧errno保存在一个局部变量中,在处理程序返回前恢复它.  
 + **阻塞所有的信号,保护对共享全局数据结构的访问.**如果处理程序和主程序或其他处理程序共享一个全局数据结构,那么在访问(读或写)该数据结构时,你的处理程序和主程序应该暂时阻塞所有的信号.  
 + **用volatile声明全局变量.**考虑一个处理程序和一个main函数,共享一个全局变量g.处理程序更新g,main周期性地读g.对于一个优化编译器而言,main中g的只看上去从来没有变化过,因此使用缓存在寄存器中g的副本来满足对g的每次引用是安全的.如果这样,main函数可能永远都无法看到处理程序更新过的值.可以使用volatile类型限定符来定义一个变量,告诉编译器不要缓存这个变量.强迫编译器每次在代码中引用g时,都要从内存中读取g的值.  
**2. 正确的信号处理**
 信号的一个与直觉不符的方面是未处理的信号是不排队的.因为pending位向量中每种类型的信号只对应有一位,所以每种类型最多只能有一个未处理的信号.因此,如果两个类型k的信号发送给一个目的进程,而因为目的进程当前正在执行信号K的处理程序,所以信号k被阻塞了,第二个信号就简单地被丢弃了;**它不会排队**.关键思想是:如果存在一个未处理的信号就表明至少有一个信号到达了.  
 
 
