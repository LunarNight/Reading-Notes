#异常控制流
 从给处理器加电开始,直到断电,程序计数器假设一个值的序列a0,a1,a2...,an-1  
 其中,每个a<sub>k</sub>是某个对应的指令I<sub>k</sub>的地址.每次从a<sub>k</sub>到a<sub>k+1</sub>的过度称为**控制转移(control transfer)**.这样的控制转移序列叫做处理器的**控制流(control flow)**.  
 现代系统通过使用控制流发生突变来对这些情况作出反应.一般把这些突变称为**异常控制流(Exceptional Control Flow,ECF)**.异常控制流发生在计算机系统的各个层次.  
 在硬件层,硬件检查侧到的事件会出发控制突然转移到异常处理程序.  
 在操作系统层,内核通过上下文切换将控制从一个用户进程转移到另一个用户进程.  
 在应用层,一个进程可以发送**信号**到另一个进程,而接受者会将控制突然转移到它的一个信号处理程序.一个程序可以通常回避通常的栈规则,并执行到其他函数中任意位置的非本地跳转来对错误作出反应.  
 理解ECF的原因:  
 + 帮助你理解重要的系统概念. ECF是操作系统用来实现I/O,进程和虚拟内存的基本机制.  
 + 帮助你理解应用程序是如何与操作系统交互的. 应用程序通过使用一个叫做陷阱(trap)或者系统调用(system call)的ECF形式,向操作系统请求服务.比如,向磁盘写数据,从网络读数据,创建一个新进程,以及终止当前进程.都是通过应用程序调用系统调用来实现的.  
 + 帮助你理解并发. ECF是计算机系统中实现并发的基本机制.在运行的并发的例子有: 中断应用程序执行的异常处理程序,在时间上重叠执行的进程和线程,以及中断应用程序执行的信号处理程序.  
 + 帮助你理解软件异常如何工作. 像c++和 Java这样的语言通过 try-catch 以及 throw 语句来提供软件异常机制.软件异常允许程序进行非本地跳转(违反通常的调用/返回栈规则的跳转)来相应错误情况.非本地跳转是一种应用层ECF.  

本章的重要性在于将开始学习应用是如何与操作系统交互的.这些交互都是围绕着ECF的.  
将描述存在于计算机系统中所有层次上的各种形式的ECF.从异常开始,异常位于硬件和操作系统交界的部分.  
还会讨论系统调用,它们为应用程序提供到操作系统的入口点的异常.  
然后会提升抽象的层次,描述进程和信号,它们位于应用和操作系统的交界之处.  
##8.1 异常
 **异常(exception)**就是控制流中的突变,来响应处理器状态的某些变化.当处理器状态中发生一个重要变化时,处理器正在执行某个当前指令I<sub>curr</sub>.在处理器中,状态被编码为不同的位和信号.状态变化称为事件(event).事件可能和当前指令的执行直接相关.比如,发生虚拟内存缺页,算法溢出,或者一条指令试图除以零.另一方面,事件也可能和当前指令的执行没有关系.比如,一个系统定时器产生信号或者一个I/O请求完成.  
 在任何情况下,当处理器检测到有事件发生时,就会通过一张叫做异常表(exception table)的跳转表,进行一个简洁过程调用(异常),到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handler)).当异常处理程序完成处理后,根据引起异常的事件类型,会发生以下3种情况中的一种:  
 + 处理程序将控制返回给当前指令,即当时间发生时正在执行的指令.  
 + 处理程序将控制返回给I next,如果没有发生异常将会执行下一条指令.  
 + 处理程序终止被中断的程序.  

###8.1.1 异常处理
 系统中可能的美中类型的异常都分配了一个唯一的非负整数的**异常号(exception number)**.其中一些号码是由处理器的设计者分配的,其他号码是由操作系统内核(操作系统常驻内存的部分)的设计者分配的.前者的示例包括被零除,缺页,内存访问违例,断点以及算术运算溢出.后者的示例包括系统调用和来自外部I/O设备的信号.  
 在系统启动时,操作系统分配和初始化一张称为**异常表**的跳转表,使得表木k包含异常k的处理程序的地址.  
 运行时(系统在执行某个程序时),处理器检测到发生了一个事件,并且确定了相应的异常号k.随后,处理器出发异常,方法是执行间接过程调用,通过异常表的表目k,转到相应的处理程序.异常号是到异常表中的索引,异常表的起始地址放在一个叫做**异常表基址寄存器**的特殊CPU寄存器里.  
 异常类似于过程调用,但是有一些重要的不同之处:  
 + 过程调用时,在跳转到处理程序之前,处理器将返回地址压入栈中.然而,根据异常的类型,返回地址要么是当前指令(当事件发生时正在执行的指令),要么是下一条指令(如果事件不发生,将会在当前指令后执行的指令).  
 + 处理器也把一些额外的处理器状态压入到栈里,在处理程序返回时,重新开始执行被中断的程序会需要这些状态.  
 + 如果控制从用户程序转移到内核,所有这些项目都被压入到内核栈中,而不是压到用户栈中.  
 + 异常处理程序运行在内核模式下,意味着它们对所有的系统资源都有完全的访问权限.  
  
  
一旦硬件出发了异常,剩下的工作就是由异常处理程序在软件中晚餐.处理程序处理完事件后,通过执行一条特殊的"从中断返回"指令,可选地返回到被中断的程序,该指令讲适当的状态弹回到处理器的控制和数据寄存器中,如果异常中断的是一个用户程序,就将恢复为用户模式,然后将控制返回给被中断的程序.  
###8.1.2 异常的类别
 异常可以分为四类: 中断(interrupt),陷阱(trap),故障(fault),终止(abort).  

类别 | 原因             |异步/同步 | 返回行为
---- | ---             | ------   | -------
中断 | 来自I/O设备的信号 | 异步     | 总是返回到下一条指令
陷阱 | 有意的异常        | 同步    | 总是返回到下一条指令
故障 | 潜在可恢复的错误  | 同步     | 可能返回到当前指令
终止 | 不可恢复的错误    | 同步     | 不会返回
 **1.中断**  
 中断是**异步**发生的,是来自处理器外部的I/O设备的信号的结果.硬件中断不是由任何一条专门的指令造成的,从这个意义上来说它是异步的.一件中断的异常处理程序常常称为**中断处理程序(intgterrupt handler).  
 
