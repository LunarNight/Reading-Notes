#优化程序性能  
 编写高效程序需要做以下几点：  
 1. 选择适当的算法和数据结构。  
 2. 理解优化编译器的能力和局限性是很重要的。  
  
 程序优化到达第一步是消除不必要的工作，让代码尽可能有效地执行所期望的任务。这包括消除不必要的函数调用,条件测试和内存引用.这些优化不依赖于目标机  器的任何具体属性.现代计算机用复杂的技术来处理机器级程序,并行地执行许多指令,执行顺序还可能不同于它们在程序中出现的顺序.  
 了解了处理器的运作,就可以进行程序优化的第二步,利用处理器提供的指令级并行能力,同时执行多条指令.  
 性能可能依赖于处理器设计的许多细节特性,而对此我们所知甚少,也是为什么要尝试各种技术的变形和组合的另一个原因.  
 研究程序的汇编代码标示是理解编译器以及产生的代码会如何运行的最有效手段之一.可以预测什么操作会并行执行,以及如何使用处理器资源.常常通过确认关键路径来决定执行一个循环所需要的时间(或者说,是一个时间下界).所谓关键路径是在循环的反复执行过程中形成的数据相关链.  
##5.1优化编译器的能力和局限性  
 编译器必须很小心地对程序只是用**安全化**的优化,也就是说对于程序可能遇到的多有可能的情况,在C语言标准提供的保证之下,优化后和为优化的版本有一样的行为.  
```
void twiddle1(long *xp,long *yp)
{
	*xp+=*yp;
	*xp+=*yp;
}
void twiddle2(long *xp,long *yp)
{
	*xp+=2 * *yp;
	
}
```
 在twiddle2中,两个指针指向同一个内存位置的情况称为**内存别名使用**.  
 乍一看,两个过程似乎有相同的行为.都是讲存储在由指针yp指示的位置处的值两次加到指针xp指示的位置处的值.另一方面,twiddle2的效率更高一些.它只要求三次内存引用(读\*xp,读\*yp,写\*xp),而twiddle1需要6次.如果要编译器编译过程twiddle1,我们会认为twiddle2执行的计算能产生更有效的代码.  
 不过,当xp等于yp的情况.
 ```
 twiddle1  执行
 *xp+=*xp;  //翻2倍
 *xp+=*xp;  //再翻两倍    即原值的4倍
 
 twiddle2 
 *xp+= 2* *xp; // 变为3倍
 ```
 在只执行安全化的优化中,如果编译器编译器不能确定两个指针是否指向同一个位置,必须假设什么情况都有可能,这就限制了可优化的策略.  
  
 ```
 long counter = 0;
 long f(){
 	return counter++;
 }
 long func1(){
 	return f()+f()+f()+f();
 }
 long func2(){
 	return 4*f();
 }
 ```
 上述过程中,看似 func1和func2产生的结果相同,但是函数调用的次数不同,f函数改变了全局变量counter.  
 两个函数执行的结果:  
 func1 = 0 + 1 + 2 + 3 =6;  
 func2 = 4\*0 = 0;  
 大多数编译器不会试图判断一个函数是否没有副作用,如果没有,就可能被优化成像func2亿元.  
 相反,编译器会假设最糟糕的情况,并保持所有的函数调用不变.  
 **内联函数**,即函数在编译过程中,把调用此函数的位置,替换为函数体.增加代码的数量,但是运行速度会加快一些.空间换时间.  
##5.2 表示程序性能
 引入度量标准**每元素的周期数(Cycles Per Element,CPE)**作为一种表示程序性能并指导改进代码的方法.  
 处理器活动的顺序是由时钟控制的,时钟提供了某个频率的规律信号,通常用**千兆赫兹(GHz)**,即十亿周期美妙来标示.例如,当表明一个系统有"4Gz"处理器,标示处理器时钟运行频率为每秒4 x 10<sup>9</sup>个周期.每个时钟周期的时间是时钟频率的倒数.用时钟周期来表示度量标准更合适.度量值表示的是执行了多少条指令,而不是时钟运行的多快.  
```
void psum1(float a[],float p[],long n)
{
 	long i;
	p[0] = a[0];
	for(i = 1; i < n; i++)
		p[i] = p[i-1] + a[i];
}

void psum2(float a[],float p[],long n)
{
	long i;
	p[0] = a[0];
	for (i = 1; i < n-1; i+=2){
		float mid_val = p[i-1] + a[i];
		p[i] = mid_val;
		p[i+1] = mid_val + a[i+1];
	}
	if(i < n)
		p[i] = p[i-1] + a[i];
}
 ```
 
 
