#处理器体系结构
 一个处理器支持的指令和指令的字节级编码称为它的**指令集体系结构（ISA）**。不同的处理器家族，有不同的ISA.一个程序编译成在一种机器上运行，就不能再另一种机器上运行。  
 ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。（好像接口哦）  
##4.1 Y86-64指令集体系结构  
###4.1.1程序员可见状态
 有15个寄存器，3个1位的条件码 ZF,SF,OF, 和 PC.  
 内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址，指明数据实际存在哪个地方。  

###4.1.3指令编码
 指令集的一个重要性质就是字节编码必须有唯一的解释。因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，我们就可以决定所有其他附加字节的长度和含义。  
  
###4.2.5存储器和时钟  
 时钟寄存器（寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。  
 随机访问存储器（简称内存）存储多个字，用地址来选择该读或写哪个字。随机访问存储器的例子包括：  
 1. 处理器的虚拟内存地址，硬件和操作系统软件结合起来使处理器可以再一个很大的地址空间内访问任意的字。  
 2. 寄存器文件，寄存器标识符作为地址。  
 硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。  
 在机器级编程中，寄存器代表的是CPU中为数不多的可寻址的字，这里的地址是寄存器ID.  
  
 寄存器输出会一直保持在当前寄存器状态上，直到时钟信号上升（保持之前那个阶段的状态，信号上升才会进行更新）。  
 向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入valW上的值会被写入输入dstW上的寄存器ID指示的程序寄存器。  
 
##4.3 Y86-64的顺序实现
 各个阶段：  
 1. 取指：取值阶段从内存读取指令字节，地址为PC的值，从指令中抽取出指令指示符字节的两个四位部分，称为icode(指令代码)和ifun(指令功能).  
 2. 译码：译码阶段从寄存器文件读入最多两个操作数，得到值valA和/或valB.通常它读入指令rA和rB字段指明的寄存器，有时候是rsp.  
 3. 执行：执行阶段，算数/逻辑单元(ALU)要么执行**指令**指明的操作（根据ifun），计算内存引用的有效地址，要么增加或减少栈指针。得到的值称为valE.在此,也可能设置条件码。对传送指令来说，这个阶段会检验条件码和传送条件，条件成立就更新目标寄存器。对跳转指令来说，也会决定是否选择分支。  
 4. 访存：访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为valM.  
 5. 写回：写回阶段最多可以写两个结果到寄存器文件。  
 6. 更新PC:将PC设置成下一条指令的地址。  
  
 译码阶段，读两个操作数。执行阶段，它们和功能指示符ifun一起再提供给ALU，valE就称为了指令结果。  
 在执行跳转,call,ret时，会在执行阶段检查条件码和跳转条件来确定是否要选择分支，产生出一个一位信号Cnd.在更新PC阶段，检查这个标志，决定是否跳转。  
 
##4.3.2 SEQ硬件结构  
 硬件单元与各个处理阶段相关联：  
 **取指**： 将程序计数器寄存器作为地址，指令内存读取指令的字节。PC增加器计算valP,即增加了的程序计数器。  
 **译码**： 寄存器文件有两个读端口A和B,从这两个店口同事读寄存器值valA和valB。  
 **执行**： 根据指令的类型，将ALU用于不同的目的，对整数操作，执行指令所指定的运算。对其他指令，会作为一个加法器来计算增加或减少栈指针。或者计算有效地址，或者只是简单地加0，将一个输入传递到输出。条件码寄存器(CC)有三个条件码位。ALU负责计算条件码的新值。当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器。同样，执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号Cnd.  
 **访存**： 执行访存操作，数据内存读出或写入一个内存字。指令和数据内存访问的是相同的内存位置，但是用于不同的目的。  
 **写回**： 寄存器文件有两个写端口。端口E用来写ALU计算出来的值，端口M用来写从数据内存中读出的值。  
 **PC更新**： 程序计数器的新值选择自：valP，吓一跳指令的地址；valC,调用指令或跳转指令指定的目标地址；valM,从内存读取的返回地址。  
 
###4.3.3 SEQ的时序
 SEQ的实现包括组合逻辑和两种存储器设备：时钟寄存器（PC和CC）,随机访问存储器（寄存器文件，指令内存和数据内存）。  
 组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播。  
 PC,CC,数据内存和寄存器文件。这些单元通过一个时钟信号来控制，它出发将新值装载到寄存器以及将值写到随机访问存储器。  
 要控制处理器中活动的时序，只需要寄存器和内存的时钟控制。使所有的状态更新实际上同时发生，且只在时钟上升开始下一个周期时。
###4.3.4 SEQ的实现
 **1. 取指阶段**  
 取指阶段包括指令内存硬件单元。以PC作为第一个字节的地址，这个单元一次从内存读出10个字节。第一个字节被解释成指令字节，分为两个4位数，标号为icode和ifun的控制逻辑快计算指令和功能码，或者使之等于从内存读出的值，或者当指令地址不合法时，使这些值对应nop指令。  
 **2. 译码和写回阶段**  
 把两个阶段联系在一起是因为它们都要访问寄存器文件。  
 寄存器文件有四个端口。它支持同事进行两个读（端口A和B）和两个写（端口E和M）。每个端口都有一个地址连接和一个数据连接，地址连接是一个寄存器ID，而数据连接是一组64根线路，即可以作为寄存器文件的输出字（对读端口来说），也可以作为它的输入字（对写端口来说）。两个读端口的地址输入为srcA和srcB,而两个写端口的地址输入为dstE何dstM.如果某个地址端口上的值为特殊标识符0xF（RNONE）.则表明不需要访问寄存器。  
 **3. 执行阶段**  
 执行阶段包括算数/逻辑单元（ALU）。这个单元根据alufun信号的设置，对输入aluA和aluB执行ADD，SUBTRACT，AND或EXCLUSIVEOR运算。这些数据和控制信号是由三个控制块产生的。ALU的输出就是valE信号。  
 执行阶段的第一步就是每条指令的ALU计算。标号为cond的硬件单元会根据条件码和功能吗来确定是否进行条件分支或者条件数据传送。它产生信号Cnd,用于设置条件传送的dstE,也用在条件分支的下一个PC逻辑中。
 
 
##总结和感悟
 这一章稍微讲了一些，汇编语言是如何被翻译成机器代码，相关的操作，都对应不同的数字，并且是唯一对应。比如halt对应00，nop对应10.后面还会跟着相关寄存器指示符或长数字，来组成一段指令。  
 流水线化的重要特性是提高了系统的吞吐量，但是略微增加了延迟。非流水线就类似于，去火锅店吃火锅，一个人调底料时，其他人必须等他调完，才可以调。然而加上流水线的意思是，一个人放麻酱，别人可以同时放香菜，放海鲜汁。恩，同时执行。但是会增加一些延迟，比如你放完麻酱，相放香菜，发现有人在放香菜，你只能等等了。但是同时处理的人比较多，总的来说效率提高。  
 
 
