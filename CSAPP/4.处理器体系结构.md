#处理器体系结构
 一个处理器支持的指令和指令的字节级编码称为它的**指令集体系结构（ISA）**。不同的处理器家族，有不同的ISA.一个程序编译成在一种机器上运行，就不能再另一种机器上运行。  
 ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。（好像接口哦）  
##4.1 Y86-64指令集体系结构  
###4.1.1程序员可见状态
 有15个寄存器，3个1位的条件码 ZF,SF,OF, 和 PC.  
 内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址，指明数据实际存在哪个地方。  

###4.1.3指令编码
 指令集的一个重要性质就是字节编码必须有唯一的解释。因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，我们就可以决定所有其他附加字节的长度和含义。  
  
###4.2.5存储器和时钟  
 时钟寄存器（寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。  
 随机访问存储器（简称内存）存储多个字，用地址来选择该读或写哪个字。随机访问存储器的例子包括：  
 1. 处理器的虚拟内存地址，硬件和操作系统软件结合起来使处理器可以再一个很大的地址空间内访问任意的字。  
 2. 寄存器文件，寄存器标识符作为地址。  
 硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。  
 在机器级编程中，寄存器代表的是CPU中为数不多的可寻址的字，这里的地址是寄存器ID.  
  
 寄存器输出会一直保持在当前寄存器状态上，直到时钟信号上升（保持之前那个阶段的状态，信号上升才会进行更新）。  
 向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入valW上的值会被写入输入dstW上的寄存器ID指示的程序寄存器。  
 
##4.3 Y86-64的顺序实现
 各个阶段：  
 1. 取指：取值阶段从内存读取指令字节，地址为PC的值，从指令中抽取出指令指示符字节的两个四位部分，称为icode(指令代码)和ifun(指令功能).  
 2. 译码：译码阶段从寄存器文件读入最多两个操作数，得到值valA和/或valB.通常它读入指令rA和rB字段指明的寄存器，有时候是rsp.  
 3. 执行：执行阶段，算数/逻辑单元(ALU)要么执行**指令**指明的操作（根据ifun），计算内存引用的有效地址，要么增加或减少栈指针。得到的值称为valE.在此,也可能设置条件码。对传送指令来说，这个阶段会检验条件码和传送条件，条件成立就更新目标寄存器。对跳转指令来说，也会决定是否选择分支。  
 4. 访存：访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为valM.  
 5. 写回：写回阶段最多可以写两个结果到寄存器文件。  
 6. 更新PC:将PC设置成下一条指令的地址。  
  
 译码阶段，读两个操作数。执行阶段，它们和功能指示符ifun一起再提供给ALU，valE就称为了指令结果。  
 在执行跳转,call,ret时，会在执行阶段检查条件码和跳转条件来确定是否要选择分支，产生出一个一位信号Cnd.在更新PC阶段，检查这个标志，决定是否跳转。  
 
##4.3.2 SEQ硬件结构  
 硬件单元与各个处理阶段相关联：  
 **取指**： 将程序计数器寄存器作为地址，指令内存读取指令的字节。PC增加器计算valP,即增加了的程序计数器。  
 **译码**： 寄存器文件有两个读端口A和B,从这两个店口同事读寄存器值valA和valB。  
 **执行**： 根据指令的类型，将ALU用于不同的目的，对整数操作，执行指令所指定的运算。对其他指令，会作为一个加法器来计算增加或减少栈指针。或者计算有效地址，或者只是简单地加0，将一个输入传递到输出。条件码寄存器(CC)有三个条件码位。ALU负责计算条件码的新值。当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器。同样，执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号Cnd.  
 **访存**： 执行访存操作，数据内存读出或写入一个内存字。指令和数据内存访问的是相同的内存位置，但是用于不同的目的。  
 **写回**： 寄存器文件有两个写端口。端口E用来写ALU计算出来的值，端口M用来写从数据内存中读出的值。  
 **PC更新**： 程序计数器的新值选择自：valP，吓一跳指令的地址；valC,调用指令或跳转指令指定的目标地址；valM,从内存读取的返回地址。  
 
###4.3.3 SEQ的时序
 SEQ的实现包括组合逻辑和两种存储器设备：时钟寄存器（PC和CC）,随机访问存储器（寄存器文件，指令内存和数据内存）。  
 组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播。  
 PC,CC,数据内存和寄存器文件。这些单元通过一个时钟信号来控制，它出发将新值装载到寄存器以及将值写到随机访问存储器。  
 要控制处理器中活动的时序，只需要寄存器和内存的时钟控制。使所有的状态更新实际上同时发生，且只在时钟上升开始下一个周期时。
###4.3.4 SEQ的实现
 **1. 取指阶段**  
 取指阶段包括指令内存硬件单元。以PC作为第一个字节的地址，这个单元一次从内存读出10个字节。第一个字节被解释成指令字节，分为两个4位数，标号为icode和ifun的控制逻辑快计算指令和功能码，或者使之等于从内存读出的值，或者当指令地址不合法时，使这些值对应nop指令。  
 **2. 译码和写回阶段**  
 把两个阶段联系在一起是因为它们都要访问寄存器文件。  
 寄存器文件有四个端口。它支持同事进行两个读（端口A和B）和两个写（端口E和M）。每个端口都有一个地址连接和一个数据连接，地址连接是一个寄存器ID，而数据连接是一组64根线路，即可以作为寄存器文件的输出字（对读端口来说），也可以作为它的输入字（对写端口来说）。两个读端口的地址输入为srcA和srcB,而两个写端口的地址输入为dstE何dstM.如果某个地址端口上的值为特殊标识符0xF（RNONE）.则表明不需要访问寄存器。  
 **3. 执行阶段**  
 执行阶段包括算数/逻辑单元（ALU）。这个单元根据alufun信号的设置，对输入aluA和aluB执行ADD，SUBTRACT，AND或EXCLUSIVEOR运算。这些数据和控制信号是由三个控制块产生的。ALU的输出就是valE信号。  
 执行阶段的第一步就是每条指令的ALU计算。标号为cond的硬件单元会根据条件码和功能吗来确定是否进行条件分支或者条件数据传送。它产生信号Cnd,用于设置条件传送的dstE,也用在条件分支的下一个PC逻辑中。
 **4. 访存阶段**  
 访存阶段的任务就是读或者写程序数据。两个控制块产生内存地址和内存输入数据的值。另外两个块产生表明应该执行读操作还是写操作的操作信号。当执行度操作时，数据内存产生值valM.内存读和写的地址总是valE或valA.  
 **5. 更新PC阶段**  
 依据指令的类型和是否要选择分支，新的PC可能是valC,valM或valP.  
##4.4流水线的通用原理
 流水线化的一个重要特性就是提高了系统的**吞吐量**，也就是单位时间内服务的顾客总数，不过它也会轻微地增加**延迟**，也就是服务一个用户所需要的时间。  
###4.4.2 流水线操作的详细说明
 流水线阶段之间的指令转移是由时钟信号来控制的。信号由0上升至1，开始下一组流水线阶段的计算。如果时钟运行的太快，会有灾难性的后果，值可能来不及通过组合逻辑，因此当时钟上升时，寄存器的输入还不是合法的值。  
###4.4.3 流水线的局限性
 **1. 不一致划分**  
 每个阶段，通过组合逻辑的时间所需都不同，应该以最大的为准，来确定一个时钟周期。（需要看图A.50ps B.150ps C100ps 寄存器20ps,周期：150+20ps）  
 **2. 流水线过深，收益反而下降**  
 增加的寄存器太多，由于通过流水线寄存器会有延迟，所以吞吐量病没有加倍增长，这个延迟就成为了主要的制约因素。  
 带反馈的流水线系统，当包含三条指令的序列中，每条相邻的指令之间都有**数据相关**，第二条指令会用到第一条指令的值，这时候需要一个反馈。  
##4.5 Y86-64的流水线实现
###4.5.1 SEQ+: 重新安排计算阶段  
 在SEQ中，PC计算发生在时钟周期结束的时候，根据当前时钟周期内计算出的信号值来计算PC寄存器的新值。  
 在SEQ+中，我们创建状态寄存器来保存在一条指令执行过程中计算出来的信号，然后当一个新的时钟周期开始时，这些信号值通过同样的逻辑来计算当前指令的PC。  
###4.5.2 插入流水线寄存器
 流水线寄存器按如下方式标号：  
 F. 保存程序计数器的预测值  
 D. 位于取指和译阶段之间。它保存相关最新取出的指令的信息，即将由译码阶段进行处理。  
 E. 位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值的信息，即将由执行阶段进行处理。  
 M. 位于执行和访存阶段之间。它保存最新执行的指令的结果，即由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。  
 W. 位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当晚餐ret指令时，它还要向PC选择逻辑提供返回地址。  
 
###4.5.3对信号进行重新排列和标号
 SEQ+和PIPE-的译码阶段都产生信号dstE和dstM,它们致命valE和valM的目的寄存器。在PIPE-中，会在流水线中一直携带这些信号穿过执行和访存阶段，知道写回阶段才送到寄存器文件。这样确保写端口的地址和数据输入时来自同一条指令。否则，会将处于写回阶段的指令的值写入，而寄存器ID却来自于译码阶段的指令。作为一条通用原则，我们要保存处于一个流水线阶段中的指令的所有信息。  
 只有CALL在访问阶段需要valP的值，只有跳转指令在执行阶段需要（不需要进行跳转）valP的值。而这些指令又都不需要从寄存器文件中读出的值，因此合并两个信号，将他们作为信号valA携带穿过流水线。  
###4.5.4预测下一个PC
 流水线化设计的目的就是每个时钟周期都发射一条新指令，每个时钟周期都有一条新指令进入执行阶段并最终完成。  
 如果取出的指令是条件分支指令，要到几个周期后，指令通过执行阶段之后，才能知道是否要选择分支。  
 如果取出的指令时ret,要到指令通过访存阶段，才能确定返回地址。  
 猜测分支方向病根据猜测开始取指的技术称为**分支预测**。依次加载每条指令，可能1，可能2，不选择，然后再选择其中一条，丢掉另两条指令。  
 没有讨论猜测ret指令的新PC值。可能的返回值几乎是无限的，因为返回地址是位于栈顶的字，其内容可以是任意的。  
###4.5.5流水线冒险
 将流水线技术引入一个带反馈的系统，当相邻指令间存在相关时会导致出现问题。问题有两种形式：  
 1. 数据相关，下一条指令会用到这一条指令计算出的结果。  
 2. 控制相关，一条指令要确定下一条指令的位置，例如在执行跳转，调用或返回指令时。  
 这些相关可能会导致流水线产生计算错误，称为**冒险**。  
  
 **1.用暂停来避免数据冒险**  
 暂停是避免冒险的一种常用技术，处理器会停止流水线中一条或多条指令，知道冒险条件不再满足。让一条指令停留在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样可以避免数据冒险。  
 暂停技术是让一组指令阻塞在它们所处的阶段，而允许其他指令继续通过流水线。（类似进程里的锁机制,不到达某一条件不让执行）  
 处理方法是：每次要把一条指令阻塞在译码阶段，就在执行阶段插入一个气泡，气泡就像一个自动产生的nop指令，不会改变寄存器，内存，条件码状态。  
 **2.用转发来避免数据冒险**  
 PIPE-的设计师在译码阶段从寄存器文件中读入源操作数，但是对这些源寄存器的写有可能要在写回阶段才能进行。与其暂停等到写完成，不如简单地将要写的值传到流水线寄存器E作为源操作数。  
 这种将结果值直接从一个流水线阶段传到焦躁阶段的技术成为**数据转发**。  
 当访存阶段中有对寄存器未进行的写时，也可以使用数据转发，可以将写回阶段的值和访存阶段中的值，传到译码阶段，只要他们有对相同寄存器的写操作。  
 还可以将新计算出来的值从执行阶段传到译码阶段。  
 转发技术可以将ALU产生的以及其目标为写端口E的值进行转发，页可以转发从内存中读出的以及其目标为写端口M的值。  
 
 **3.加载/使用数据冒险**  
 有如下代码：  
 mrmove 0(%rdx),%rax ..#Load %rax  
 addq %ebx,%eax ..#Use %rax  
 addq指令在译码阶段需要用到rax的值，但是此时mrmovq处于执行阶段，需要到访存阶段才会产生出这个值，为了从mrmovq转发到addq,转发逻辑不得不将值送回到过去的时间（需要mrmovq在访存阶段时读出这个值，转给addq的译码阶段，这两个阶段中间间隔一个执行阶段，流水线处理，中间只间隔一个小阶段，这间隔了两个阶段）。  
 可以把暂停和转发结合起来，避免加载/使用数据冒险。当mrmoveq指令通过执行阶段时，流水线控制逻辑发现译码阶段中的指令addq需要从内存中读出的结果，它会将译码阶段中的指令暂停一个周期，插入一个气泡，再把内存中读出的值从访问阶段转发到译码阶段中的addq指令。（其实就是让addq暂停一下，使mrmove往前执行一次，把从内存中读出的数值传回来）。  
 
 **4.避免控制冒险**  
 当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险。当取出ret指令，病沿着流水线前进，在它经过译码，执行和访存阶段时，流水线不能做任何有用的活动，只能在流水线中插入三个气泡。一旦ret指令到达写回阶段，PC选择逻辑就会将程序计数器设为返回地址。  
 
###4.5.6异常处理
 指令集体系结构包括三种不同的内部产生的异常：  
 1. halt指令  
 2. 有非法指令和功能码组合的指令  
 3. 取指或数据读写师徒访问一个非法地址。  
  
 第一个细节问题，有多个异常出现该怎么办。  
 异常优先级的基本原则：由流水线中最深的指令引起的异常，优先级最高。  
  
 第二个细节问题，首先取出一条指令执行，导致了一个异常，而后来由于分支预测错误，取消了该指令。  
 流水线会预测选择分支，因此它会取出并以一个值为0xFF的字节作为指令。译码阶段会因此发现一个非法指令异常。稍后流水线会发现不应该选择分支，流水线控制逻辑结构会取消该指令，但是我们想要避免出现异常。  
 第三个细节问题，流水线化的处理器会在不同的阶段更新系统状态的不同部分，当一条指令导致了一个异常，它的后面的指令在异常指令完成之前就改变了部分状态。  
 一般地，通过在流水线结构中加入异常处理逻辑，我们能够从各个异常中做出正确的选择，页能够避免出现由于分支预测错误取出的指令造成的异常。  
 可以在每个流水线寄存器中包括一个状态码stat。如果一条指令在其处理中于某个阶段产生了一个异常，这个状态字段就会被设置成标示异常的种类。异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回阶段。在此，流水线控制逻辑发现出现了异常，并停止执行。  
 为了避免异常指令之后的指令更新任何程序员可见的状态，当处于访存或写回阶段中的指令导致异常时，流水线控制逻辑必须禁止更新条件码寄存器或是数据内存。  
 **解决**  
 当流水线中有一个或多个阶段出现异常时，信息只是简单地存放在流水线寄存器的状态字段中。异常事件不会对流水线中的指令流有任何影响，除了会**禁止**流水线中**后面**的指令更新程序员可见状态（条件码寄存器和内存），知道异常指令到达最后的流水阶段。因为指令到达写回阶段的顺序与它们在非流水线化的处理器中执行的顺序相同，所以我们可以保证第一条遇到异常的指令会第一个到达写回阶段，此时程序执行会停止，流水线寄存器W中的状态码会被记录微程序状态。如果取出了某条指令，过后又取消了，那么所有关于这条指令的异常状态信息也都会被取消。  
 
###4.5.7 PIPE各阶段的实现
 **1. PC选择和取值阶段**  
 这个阶段必须选择程序计数器的当前值，并且预测下一个PC值.  
 **2. 译码和写回阶段**  
 提供给写端口的寄存器ID来自于写回阶段(信号W_dstE和W_dstM)，而不是来自于译码阶段。这是因为我们希望进行 写的目的寄存器是由写回阶段中的指令指定的;流水线化的实现应该总是给处于最早流水线阶段中的转发源以较高的优先级，因为它保持着程序序列中设置该寄存器的最近的指令。逻辑首先会检测执行阶段中的转发源，然后是访存阶段，最后才是写回阶段。  
 **3. 执行阶段**  
 标号为"Set CC"的逻辑以信号m_stat和W_stat作为输入，这个逻辑决定了是否要更新条件码，这些信号被用来检查一条导致异常的指令正在通过后面的流水线阶段的情况，因此任何对条件码的更新都会被禁止。  
 **4. 访存阶段**  
 许多从流水线寄存器M和W来的信号被传递到焦躁的阶段，以提供写回的结果、指令地址以及转发的结果。  
###4.5.8流水线控制逻辑  
 流水线控制逻辑必须处理下面4种控制情况：  
 **加载/使用冒险**：在一条从内存中读出一个值的指令和一条使用该值的指令之间，流水线必须暂停一个周期。  
 **处理ret**:流水线必须暂停直到ret指令到达写回阶段。  
 **预测错误的分支**:在分支逻辑发现不应该选择分支之前，分支目标的几条指令已经进入流水线了，必须取消这些指令，并从跳转之后后面的那条指令开始取消。  
 **异常**：当一条指令导致异常，我们想要禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段时，停止执行。  
  
 **1. 特殊控制情况所期望的处理**  
 只有mrmovp和popq指令会从内存中读数据。这两条指令中的任一条处于执行阶段时，并且需要该目的寄存器的指令正处在译码阶段，要将第二条指令阻塞在译码阶段，并在下一个周期往执行阶段中插入一个气泡。伺候，转发逻辑会解决这个数据冒险。  
 当分支预测错误发生。当跳转指令到达执行阶段时就可以检测到预测错误。然后在下一个时钟周期，控制逻辑就会在译码和执行阶段插入气泡，取消两条不正确的已取指令。在同一个时钟周期，流水线将正确的指令读取到取指阶段。  
 对于导致异常的指令，需要在前面所有指令结束前，后面的指令不能影响程序的状态。一些因素会使得达到此效果比较麻烦：1.异常在程序执行的两个不同阶段被发现。2.程序状态在三个不同阶段（执行，访存，写回）被更新。设计中，每个流水线处理器都会包含一个stat状态码，会记录指令的状态。当异常发生时，将这个信息作为指令状态的一部分记录下来，并且继续取指，译码和执行指令，好像什么都没有出错一样。当异常到达访存阶段时，会采取措施防止后面的指令修改程序可见状态：1.禁止执行阶段中的指令设置条件码。2.向内存阶段中插入气泡，以禁止数据内存中写入。3.当写回阶段中有异常指令时，暂停写回节点，因而暂停了流水线。  
 **2. 发现特殊控制条件**  
 当ret指令通过流水线时，要想发现它，只要检查译码，执行和访存阶段中指令的指令码。发现加载/使用冒险要检查执行阶段中的指令类型（mrmovq或popq），并把它的目的寄存器与译码阶段中指令的源寄存器相比较。  
 当跳转指令在执行阶段时，流水线控制逻辑应该能发现预测错误的分支，这样当指令进入访存阶段时，就能设置从错误预测中恢复所需要的条件。当跳转指令处于执行阶段时，信号e_Cnd指明是否要选择分支，通过检查访存和写回阶段中的指令状态值，就能发现异常指令。  
 **3. 流水线控制机制**  
 流水线寄存器有两个控制输入：暂停和气泡。  
 
 
 
 
##总结和感悟
 这一章稍微讲了一些，汇编语言是如何被翻译成机器代码，相关的操作，都对应不同的数字，并且是唯一对应。比如halt对应00，nop对应10.后面还会跟着相关寄存器指示符或长数字，来组成一段指令。  
 流水线化的重要特性是提高了系统的吞吐量，但是略微增加了延迟。非流水线就类似于，去火锅店吃火锅，一个人调底料时，其他人必须等他调完，才可以调。然而加上流水线的意思是，一个人放麻酱，别人可以同时放香菜，放海鲜汁。恩，同时执行。但是会增加一些延迟，比如你放完麻酱，相放香菜，发现有人在放香菜，你只能等等了。但是同时处理的人比较多，总的来说效率提高。 
 
 讲了许多相关硬件是如何进行处理数据，相互配合，实现一个处理器。先是实现一个简单的处理器，类似串行计算，后来由于为了提高效率，提出了流水线化，类似于并行计算的概念；然而由于流水线化的出现，可能指令和指令之间会出现冒险状况，也就是说，后面的指令需要用到前面的指令的数据，但是前面的指令还没有执行完，如果这时候用到了未更新的数据，这样会导致错误；为了处理这种错误，又提出了暂停和冒泡的方法来解决，何时暂停，何时冒泡，都有不同的条件，通过暂停和冒泡，可以把更新后的数据，或者是在读的数据，进行转发，然后解决这种冒险问题。又讲述了异常的一些处理方式，为了使异常指令后面的指令不再执行，而又不影响之前的指令，提出了stat状态码，出现异常时改变它，并沿着流水线传递，禁止后面的指令改变内存和条件码，到达回写的阶段就停止执行，这样程序员就不会看到错误代码之后的代码产生的影响，而之前的代码又全部执行完毕。  
 到了最后，也有部分没有实现的功能，比如浮点数处理，乘除法之类，提出的思想是，为了更好的性能，有一个功能单元来执行整数乘法和出发，还有一个来执行浮点操作，当一条代码进入译码阶段时，被发射到特殊的单元。这就类似于，把功能分开，当编程时，后台有比较重要功能的时候，应该把这些功能分开来写，容易维护一点吧。都写在一起，可能会影响效率。或者说，把功能拆开，几个比较复杂的功能放到不同的服务器，提高效率，省的一个服务器炸了，所有功能都完蛋。不知道这样是否可行，只是猜测。  
 继续上面说，浮点单元本身也是流水线化的，指令也可以并发执行，然而不同单元的操作必须同步，以避免出错。这样的化，上述把功能放到不同的服务器，可能就会遇到一点问题，它们可能需要用同一个数据库，操作的同时进行更新，或许会有延迟等问题。哎呀呀，闹不清线程这一块。等回过头来看的时候或许有新的理解吧。  
 感觉这一章的内容，虽然不太懂吧，但又觉得很有用，却又觉得没学到什么东西。也就是 串行变并行。暂停和冒泡的思想（多线程里的锁机制）。异常的处理（设置标志位进行传递）。最后自己瞎猜的把功能拆开。反正觉得这一章很有用，也就是思想有用吧。具体处理器的相关实现，还是算了吧。。
