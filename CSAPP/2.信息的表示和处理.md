##2.1信息存储
大多数计算机使用8位的块,或者字节作为最小的可寻址的存储器单位.  
机器级程序将存储器视为一个非常大的字节数组,称为**虚拟存储器**.存储器的每个字节都有一个唯一的数字来标识,称为**地址**.所有可能地址的集合称为**虚拟地址空间**.  
###2.1.2字
每台计算机都有一个字长,指明整数和指针数据的标称大小.因为虚拟地址是以这样一个子来编码的,所以子长决定的最重要的系统参数就是虚拟地址空间的最大大小.大多数计算机字长是32位,就限定了虚拟地址空间为4千兆字节(4GB).  
###2.1.3数据大小
如果声明一个int型的程序对象能被用来存储一个指针.在大多数32位机器上能正常工作,但是在一台64位的机器上却会导致问题.(因为int表示的范围是2^31-1,但是64位系统中可访问的内存地址 可能比它的最大值大,如果访问的话,会发生错误)  
###2.1.4 寻址和字节顺序
最低有效字节在最前面的方式,称为**小端法**.  
最高有效字节在最前面的方式,称为**大端法**.  
假设变量x类型为int,位于地址 0x100处,十六进制值为 0x01234567.地址范围为0x100~0x103的字节.其排列顺序:  
大端法: 0x100(01) 0x101(23) 0x102(45) 0x103(67)  
小端法: 0x100(67) 0x101(45) 0x102(23) 0x103(01)  
不同类型的机器之间通过网络传送二进制数据时,常见问题是当小端法机器产生的数据被发送到大端法机器或者反方向发送时挥发性,接收程序子里的字节成了反序的.  
不同的机器/操作系统配置使用不同的存储分配规则.  
###2.1.5 表示字符串
C语言中字符串被编码为一个以null(值为0)字符结尾的字符数组.每个字符都由某个标准编码来表示,最常见的是ASCII字符码.在使用ASCII码作为字符码的任何系统上将得到相同的结果,与字节顺序和子大小规则无关.因而文本数据比二进制数据具有更强的平台独立性.  
###2.1.6表示代码
不同机器类型使用不同的且不兼容的指令和编码方式.即使是完全一样的进程运行在不同的操作系统上也会有不同的编码规则,因此二进制代码是不兼容的.二进制代码很少能在不同机器和操作系统组合之间移植.比如WINDOWS下编译出的程序不能在LINUX中运行.  
###2.1.10C语言中的移位运算
表达式a&&5/a 将不会造成0被整除,表达式p&&\*p++也不会导致间接引用空指针.  
左移:向低位补n个0.  
逻辑右移:向最高位补n个0.  
算数右移:向最高位补n个最高位的值.(负数情况下补1)  
对于无符号数,右移必须是逻辑.而对于符号数,几乎所有的编译器都是使用算数右移.  
**移位运算符有关的操作符优先级问题**
表达式:1\<\<2+3\<\<4,其本意是(1\<\<2)+(3\<\<4).但是在c中,前面表达式等价于1\<\<(2+3)\<\<4,因为假发的优先级比移位运算要高.最好是加上括号.  
##2.2整数表示
###2.2.1整数数据类型
在C中,支持多种整型数据类型,每种类型都能用关键字来指定大小,这些关键字包括char,short,long,或long long.同时可以指定贝表示数字是非负数(unsigned).  
这些不同大小的分配的字节数会根据机器的字长和编译器有所不同.  
比如大小指示符long,大多数64位机器使用8个字节表示,比32位机器上使用的四个字节表示的取值范围大很多.  
取值范围是不对称的--负数的范围比整数的范围大1.  
int  Min:-2147483648  Max:2147483647  
###2.2.2数的编码
无符号数: 介于0~2<sup>w</sup> -1之间.w代表位数.  
**补码**编码: 将字的最高有效位解释为负权.表示范围 Min:-2<sup>w-1</sup> Max:2<sup>w-1</sup>-1.  
之所以会有这样的不对称性,是因为一半的位模式(符号位设置为1的数)表示负数,而一半的数(符号位设置为0的数)表示非负数.  
因为0是非负数,也就意味着表示的正数比负数少一个.  
在字长为16位中. UMax:0xFFFF(65535) TMin:0x8000(-32768) TMax:0x7FFF(32767) -1:0xFFFF 0:0x0000.  
**原码**:最高有效位是符号位,用来确定剩下的位应该取负权还是正权.  
**反码**:除了最高有效位的权是-(2<sup>w-1</sup>-1)而不是-2<sup>w-1</sup>,它和补码是一样的.  
对于数字0有两种不同的编码方式.把[00...0]都解释为+0. 而值-0在源码中表示为[10...0],在反码中表示为[11...1].  
###2.2.4有符号数和无符号数之间的转换  
对于这个问题,回答都是从位级角度来看的.  
```
int main(){
	short k = -12345;
	unsigned short v =(unsigned short) k;
	printf("%d\n",k);  //-12345
	printf("%d",v);    //53191
}
```
将有符号位，变为无符号位，不改变位的表示，只是改变了解释这些位的方式.反过来也是同样的道理.  
在c中,出大多数数字都默认是有符号的,要创建一个无符号常量,必须加上后缀字符U或u.  
用printf输出数值时,可用%d,%u,&x表示 有符号十进制,无符号十进制,十六进制格式输出一个数字.  
在c中,如果一个运算数是有符号的而另一个是无符号的,那么c语言会隐式的将有符号参数强制类型转换为无符号数.并假设两个数都是非负.  
这种方法对于标准的算数运算来说没多大差异,但是对于像<和>这样的关系运算符来说,会导致非直观的结果.  
例如:比较 -1\<0U.因为第二个运算符是无符号的,第一个运算数就会被隐式地转换为无符号数,因此表达式就等价于4294967295U\<0U.FALSE  
###2.2.6扩展一个数字的位表示
将一个无符号数转换成一个更大的数据类型,只需要简单的在开头添加0,这种运算称为**零扩展**.  
将一个补码数字转换为一个更大的数据类型可以执行**符号扩展**,在表示中添加最高有效位的值的副本(如果是负数,就添加1).  
[1011] [11011] [111011]都表示 -5.  
```
short sx = -12345; // -12345
unsigned uy = sx;  // 4294954951
// 先对sx改变大小,再完成从有符号数到无符号数的转换.
//即unsigned sx 等价于 (unsigned)(int)sx,得到4294954951.而不是(unsigned)(unsigned short)sx.求得53191.这个规则是c语言要求的.
```  
###2.2.7截断数字
```
int x = 53191;
short sx = (short) x;//-12345
int y = sx;          //-12345
```
对于一个无符号数，截断它到k位的结果就相当于计算x mod 2<sup>k</sup>.  
##2.3 整数运算
有时,两个整数相加会得出一个负数,并且比较表达式 x\<y 和比较表达式 x-y\<0会产生不同的结果.这是由于计算机运算的有限性造成的.  
###2.3.1无符号加法
两个无符号数值相加时,结果可能会溢出.  
如果限制字长为4.计算  15+10 = 25. 然而实际应该是  25-16 = 9.  
两个数相加溢出后,结果会比他们两个都小.可依次来进行判断结果是否溢出.  
###2.3.2补码加法
给定在范围-2<sup>w-1</sup>\<=x,y\<=<sup>w-1</sup>-1之内的整数值x和y.  
它们和的范围: -2<sup>w</sup>\<=x+y\<=2<sup>w</sup>-2.  
如果:2<sup>w-1</sup>\<=x+y, x+y-2<sup>w</sup> ,正溢出  
如果:-2<sup>w-1</sup>\<=x+y\<=<sup>w-1</sup>-1, x+y 正常  
如果:x+y\<-2<sup>w-1</sup>,  x+y+2<sup>w</sup>,负溢出  
###2.3.3.补码的非
-<sub>w</sub>x =  
第一种情况: -2<sup>w-1</sup>,x = -2<sup>w-1</sup>.  
第二种情况: -x,x>-2<sup>w-1</sup>.  
即补码取反+1.  
###2.3.4乘法  
**无符号乘法**  
结果为 (x\*y)mod 2<sub>w</sub>  
**补码乘法**  
将2w位的乘积阶段为w位来实现,然后再按照有符号数的方式进行读.  
比如 -3[101] * 3[011]  结果 -9[110111] 截取三位 -1[111] 即结果.  
无符号和补码乘积的**低位**是相同的.  
**乘以常数**
编译器使用了一项重要的优化,试着用移位和加法运算的组合来代替乘以常数因子的乘法.  
假设一个程序包含表达式 x\*14.利用等式 14=2<sub>3</sub>+2<sub>2</sub>+2<sub>1</sub>,编译器会把乘法重写为(x\<\<3)+(x\<\<2)+(x\<\<1)  
实现了将一个乘法替换为三个移位和两个加法,无论x是无符号的还是补码,甚至当乘法会导致溢出时,两个计算都会得到一样的结果.  
更好的方法是,编译器还可以利用属性14 = 2<sub>4</sub> - 2<sub>1</sub>,将乘法重写为(x\<\<4)-(x\<\<1).这是只需要两个移位和一个减法.  
###2.3.7除以2的幂
除以2的幂可以用移位运算来实现,只不过是右移.无符号和补码数分别使用逻辑移位和算数移位来达到目的.  
对于无符号变量x,进行移位时,结果会向零舍入. 9 / 2 = 4.  
对于**补码**数进行算数右移,对于非负数来说,算数右移k位与除以2<sup>k</sup>.是一样的.  
作为一个负数的例子,对于不需要舍入的情况结果是正确的.如果需要进行舍入时,移位导致结果向下舍入,-7 / 2 = -4.  
为了修正上面不合适的舍入,可以再移位前 **偏置** 这个值.  
对于整数x和任意y\>0的y,有[x\/y] = [(x+y-1)\/y].也就是说,通过给x增加一个偏量y-1,然后再将出发向下舍入,当y整除x时,我们得到k,否则得到k+1.因此对于x\<-,如果在右移之前,先将x加上2<sup>k</sup>-1,那么就可以得到正确的舍入结果了.  
C表达式: (x\<0 ? (x + (1\<\<k) -1) : x) \>\> k  
由于x为负数时,结果总是会向下舍入,即所得的数会小1.  
除以2的幂可以通过逻辑或算数右移实现,但是不能推广到任意常数.不能用除以2的幂的出发来表示除以任意常数K的除法.
  
  
  




