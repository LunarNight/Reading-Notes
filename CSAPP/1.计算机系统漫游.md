## 1.1信息就是位+上下文
hello程序的声明周期是从一个**源程序**(源文件)开始的.即用编辑器创建并保存的文本文件.  
源程序实际上是由值0和1组成的位(bit)序列,8个位被组织成一组,称为**字节**.每个字节表示程序中某个文本字符.  
大多数现代系统都使用ASCII标准来表示文本字符.也就是用一个唯一的**单字节**大小的整数值来表示每个字符.  
hello.c程序以字节序列的方式存储在文件中.每个字节都有一个整数值,该整数值对应于某个字符.  
(字节是表示的是空间,整数值是字节中保存的数,这个数值即是ASCII码,可以表示某个字符)  
```
#   i   n   c   l   u   d   e   <sp>  
35  105 110 99  108 117 100 101  32
```
像hello.c这种只由ASCII字符构成的文件称为**文本文件**,所有其它文件都称为**二进制文件**.  
文本文件:基于字符编码,比如ASCII,UNICODE编码等等.基本上是定长编码,ASCII是8位,UNICODE一般是16位.  
二进制文件:基于值编码,可看成是变长编码的，因为是值编码，多少个比特代表一个值，完全由自己决定.  

系统中所有的信息--包括磁盘文件,存储器中的程序,存储器中存放的用户数据一级网络上传送的数据都是由一串位表示的.  
区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文.比如,在不同的上下文中,一个同样的字节序列可能表示一个整数,浮点数或字符串.  
## 1.2程序被其他程序翻译成不同的格式
在系统上运行hello.c程序,每条C语句都必须被其他程序转化为一系列的低级**机器语言**之类.然后这些指令按照**可执行目标程序**的格式打包,以二进制磁盘文件的形式存放起来.目标程序称为**可执行目标文件(.exe)**  
一半从源文件到目标文件的转化是由编译器驱动程序完成的:gcc -o hello hello.c  
GCC编译器驱动程度读取hello.c,把它翻译成.exe.翻译过程分为四个阶段完成,这四个阶段的程序一起构成编译器系统.  
hello.c->预处理器(cpp)->生成hello.i(被修改的源程序,文本)->编译器(ccl)->生成hello.s(汇编程序,文本)  
->汇编器(as)->生成hello.o(可重定位目标程序,二进制)->链接器(ld)->生成hello(可执行目标程序,二进制)  
1. 预处理阶段.预处理器把#开头的命令所包含的文件,插入到程序文本中,得到另一个c程序.  
2. 编译阶段.把hello.i翻译成hello.s.生成汇编语言的一个文件.  
3. 汇编阶段.汇编器将hello.s翻译成机器语言指令,指令打包成**可重定位目标程序**的格式.保存在hello.o,它的字节编码是机器语言指令.  
4. 链接阶段.链接器将其他的,如printf.o预编译好的文件,和主文件进行链接,生成hello文件.  

## 1.4处理器读并解释存储在存储器中的指令
**1. 总线**.贯穿整个系统的是一组电子管道,称作**总线**.它携带信息字节并负责在各个部件间传递.通常总线被设计成传送定长的字节块,也就是**块**.  
字中的字节数(字长)是一个基本的系统参数,根据操作系统中的位数而定.有的机器字长是4个字节(32位),有的是8个字节(64位).  
**2. I/O设备**.输入/输出设备是系统与外部世界的联系通道.作为用户输入的键盘和鼠标,作为用户输出的显示器.以及用于长期存储数据和程序的磁盘驱动器.  
每个I/O设备都通过一个**控制器**或**适配器**与总线相连.  
**3. 主存**.主存是一个临时存储设备,在处理器执行程序时,用来存放程序和程序处理的数据.  
**4. 处理器**中央处理单元(CPU),简称处理器,是解释存储在主存中指令的引擎.处理器核心是一个字长的存储设备(或寄存器).称为**程序计数器**(PC).在任何时刻PC都指向主存中的某条机器语言指令(含有该指令的地址).  
## 1.6存储设备形成的层次结构
在处理器和一个又大又慢的设备(例如主存)之间插入一个更小更快的存储设备(例如高速缓存)的想法已经称为了一个普遍的观念.每个计算机系统的存储设备都被组织成了一个**存储器层次结构**.  
存储器层次结构的主要思想是一层上的存储器作为低一层存储器的高速缓存.在某些具有分布式文件系统的网络系统中,本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存.  
## 1.7操作系统管理硬件
hello程序没有直接访问键盘,显示器,磁盘或主存, 而是依靠**操作系统**提供的服务.  
操作系统有两个基本功能:  
1. 防止硬件被失控的应用程序滥用.  
2. 向应用程序提供简单一直的机制 来控制 复杂而又通常大相径庭的 硬件设备.  
操作系统通过进程,虚拟存储器和文件 来实现这两个功能.  
文件是对I/O设备的抽象表示,虚拟存储器是对主存和磁盘I/O设备的抽象表示.进程则是对处理器,主存和I/O设备的抽象表示.  
### 1.7.1进程
**进程**是操作系统对一个正在运行的程序的一种抽象.并发运行,是说一个进程的指令和另一个进程的指令交错执行.一个CPU看上去都像在并发地执行多个进程,这是通过处理器在进程间切换来实现的.操作系统实现这种交错执行的机智称为**上下文切换**.  
操作系统保持跟踪进程运行所需的所有状态信息,这种状态称为**上下文**.包括许多信息,例如PC和存储器文件的当前值,以及主存的内容.在任何一个时刻,单处理器系统都只能执行一个进程的代码.当 操作系统决定要把控制权从当前进程专一到某个新进程时,会进行上下文切换.即保存当前进程的上下文,恢复新进程的上下文,然后将控制权传递到新进程.新进程会从上次停止的地方开始.  

### 1.7.2线程
一个进程实际上可以由多个称为**线程**的执行单元组成,每个线程运行在进程的上下文中,并共享同样的代码和全局数据.  
### 1.7.3虚拟存储器
虚拟存储器是一个抽象概念,它为每个进程提供了一个假象,即每个进程都在独占地使用主存.每个进程看到的是一直的存储器,称为**虚拟地址空间**.  
简单介绍每一个区:  
1. 程序代码和数据.对所有的进程来说,代码是从同一固定地址开始,紧接着是和c全局变量相对应的位置.  
2. 堆.代码和数据区后紧随的是运行时堆.堆可以在运行时动态地扩展和收缩.例如c中调用malloc和free.  
3. 共享库.地址空间的中间部分是用来存放像c标准库和数学哭这样共享库的代码和数去的区域.  
4. 栈.编译器用它来实现函数调用.  
5. 内核虚拟存储器.内核总是驻留在内存中,是操作系统的一部分.地址控件顶部的区域是为内核保留,不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数.  
### 1.7.4文件
文件就是字节序列.每个I/O设备,包括磁盘键盘显示器,都可以视为文件.  
文件向应用程序提供了一个同意的视角,来看待系统中可能含有的所有 各式各样的I/O设备.  
## 1.8系统之间利用网络通信
现代系统经常通过网络和其他系统连接到一起.从一个单独的系统看,网络可视为一个I/O设备.  
当从主存将一串字节复制到网络适配器时,数据流经过网络到达另一台机器,而不是其他地方,例如本地磁盘驱动器.  
## 1.9重要主题
系统不仅仅是硬件.系统是硬件和系统软件互相交织的集合体,他们需共同写作以达到运行应用程序的最终目的.  
### 1.9.1 并发和并行
并发是一个通用的概念,指一个同时具有多个活动的系统.  
并行指的是 用并发使一个系统运行得更快.并行可以在计算机系统的多个抽象层次上运用.  
1. 线程级并发
超线程,有时称为**同时多线程**,允许一个CPU执行多个控制流的技术.  
2. 指令级并行
在较低的抽象层次上,现代处理器可以同时执行多条指令的属性称为指令级并行.  
3. 单指令,多数据并行
在最低层次上,现代处理器拥有特殊的硬件,允许一条指令产生多个可以并行执行的操作,这种方式称为单指令多数据,即SIMD并行.  








