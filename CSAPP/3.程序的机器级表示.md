##3.2程序编码  
实际上GCC命令调用一系列程序,将源码转换成可执行代码.首先**C预处理器**扩展源代码,插入所有 include命令指定的文件.    
然后**编译器**产生两个源代码的汇编代码p1.s.接下来**汇编器**将汇编代码转换成二进制**目标代码**p1.o.  
目标代码是机器代码的一种形式,包含所有指令的二进制表示,但是没有填入地址的全局值.  
最后,**链接器**将两个目标文件代码与实现库函数的代码合并,并产生最终的可执行文件.  
###3.2.1 机器级代码
计算机系统使用了多种不同的形式抽象,利用更简单的模型来是隐藏实现的细节.  
对于机器编程来说,两种抽象尤为重要:  
1. 机器级程序的格式和行为,定义为**指令集体系结构**.他定义了处理器状态,指令的格式,以及每条指令对状态的影响.  
2. 机器级程序使用的存储器地址是虚拟地址,提供的存储器模型看上去是一个非常大的字节数组.存储器系统的实现是将多个硬件存货粗气和操作系统软件组合起来.  
一些处理器的介绍:  
1. 程序计数器(pc).指示将要执行的下一条指令在存储器中的地址.  
2. 整数寄存器文件包含8个命名的位置,分别存储32位的值.这些寄存器可以存储地址或整数数据.有的寄存器被用来记录某些重要的程序状态,其他的寄存器用来保存临时数据,例如局部变量和函数的返回值.  
3. 条件码寄存器保存着最近执行的算数或逻辑指令的状态信息.它们用来实现控制或数据流中的条件变化,比如实现if和while语句.  
4. 一组浮点寄存器存放浮点数据.  

 程序存储器包含:程序的可执行机器代码,操作系统需要的一些信息,用来管理过程调用和返回的运行时栈,用户分配的存储器块(malloc).程序存储器用虚拟地址来寻址.在任意给定的时刻,只认为有限的一部分虚拟地址是合法的.操作系统负责管理虚拟地址空间,将虚拟地址翻译成实际处理器存储器中的物理地址.  
 一条机器指令只执行一个非常基本的操作.例如,将存放在寄存器中的两个数字相加,在存储器和寄存器之间传送数据,伙食条件分治转移到新的指令地址.编译器必须产生这些指令的序列,从而实现程序结构.  
 要查看目标文件的内容,可以用**反汇编器**.这些程序根据目标代码产生一种类似于汇编代码的格式.  
##3.3数据格式  
 字表示16位数据类型.称32位数为 双字. int,long int都是双字形式存储的.  
##3.4 访问信息  
 一个IA32 CPU 包含一组8个存储32位值的**寄存器**.用来存储整数数据和指针.  
 eax,ecx,edx..ebx,edi,esi...ebp,esp保存着指向程序栈中重要位置的指针.  
 
###3.4.1操作数指示符
大多数指令有一个或多个**操作数**.操作数分为三种类型:  
1. 立即数.也就是常数值,任何能放进一个32位的字里的数值都可以做立即数.  
2. 寄存器.表示某个寄存器的内容,双字操作eax,字操作ax.对字节操作,可以是8个单字节寄存器中的al.  
3. 存储器引用.它会根据计算出来的地址访问某个存储器位置.  
有多种不同的**寻址方式**,比如:立即数寻址,寄存器寻址,绝对寻址,间接寻址...  
###3.4.2数据传送指令
 MOV指令,将数据从一个位置复制到另一个位置的指令.movb,movw,movl.分别是在1,2,4个字节的数据上进行操作.MOVS,符号扩展,MOVZ,零扩展.  
 第一个是源操作数,第二个是目的操作数.  
 PUSH操作,esp先 -4,然后把eax 赋值到 esp的地址中.  
 POP操作,先把esp地址中的内容 赋值到 eax,然后esp+4.  
 
###3.4.3数据传送
 C语言中所为的"指针"其实就是地址.间接引用指针就是将该指针放在一个寄存器中,然后在存储器引用中使用这个寄存器.局部变量通常也是保存在寄存器中,而不是存储器中.寄存器访问比存储器访问要快得多.  
##3.5算数和逻辑操作
 每个指令类都有对字节,字和双字数据进行操作的指令(b,w,l).这些操作被分为四组:加在有效地址,一元操作,二元操作和移位.元代表操作个数.  
###3.5.1加载有效地址
 **加载有效地址**指令leal实际上是movl指令的变形.它的指令形式是从**存储器读数据到寄存器**,但实际上他根本**没有**引用存储器.它的第一个操作数看上去是一个存储器引用,但该指令并不是从指定的位置读入数据,而是将有效地址写入到目的操作数.  
###3.5.2一元操作和二元操作
 一元操作数,只有一个操作数,即是源又是目的,这个操作数可以是一个寄存器,也可以是一个存储器位置. incl 加一操作.  
 二元操作,源操作数是第一个,目的操作数是第二个,例如,指令subl %eax,%edx. 从edx中减去eax.第一个操作数可以是立即数,寄存器或是存储器位置.第二个操作数可以是寄存器或是存储器位置.但是两个数不能同时是存储器位置.  
###3.5.3移位操作
 先给出移位量,第二项给出要移位的位数.可以进行算数和逻辑右移.移位量用单个字节编码,因为只允许进行0到31位的移位.移位量可以是一个立即数,或者存放在单字节寄存器元素cl中.  
 左移指令 SAL,SHL两者效果一样,都是将右边填上0.  
 右移指令 SAR执行算数移位(填符号位),SHR执行逻辑移位(填0).移位操作的目的操作数可以是一个寄存器或是一个存储器位置.  
###3.5.5特殊的算数操作
 乘法,要求一个参数必须在寄存器 eax中,另一个作为指令的源操作数给出.然后乘积存放在寄存器 edx(高32位)和eax(低32位)中.  
 除法,将寄存器edx和eax中的64位数作为被除数,而除数作为指令的操作数给出.指令将商存储在寄存器eax中,将余数存储在edx中.  
 
##3.6控制
 jump指令可以改变一组机器代码指令的执行顺序,jump指令指定控制应该被传递到哪个其他部分.  
###3.6.1条件码
 除了整数寄存器,CPU还维护着一组单个位的**条件码**寄存器,它们描述了最近的算数或逻辑操作的属性.可以检测这些寄存器来执行条件分支指令.常用的条件码有:  
 CF : 进位标识.最近的操作使最高位产生了进位.可以用来检查无符号操作数的溢出.  
 ZF : 零标识.最近的操作得出的结果为0.  
 SF : 符号标识.最近的操作得到的结果为负数.  
 OF : 溢出标识.最近的操作导致一个补码溢出--正溢出或负溢出.  
  
 CMP指令和TEST指令,只设置条件码而不改变任何其他寄存器.  
###访问条件码
 读取使用条件码的三种方法:  
 1. 根据条件码的某个组合,将一个字节设置为0或1, SET指令.  
 2. 可以条件跳转到程序的某个其他部分  
 3. 可以有条件地传送数据.  
 
 
 
