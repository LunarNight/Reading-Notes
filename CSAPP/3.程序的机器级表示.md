##3.2程序编码  
实际上GCC命令调用一系列程序,将源码转换成可执行代码.首先**C预处理器**扩展源代码,插入所有 include命令指定的文件.    
然后**编译器**产生两个源代码的汇编代码p1.s.接下来**汇编器**将汇编代码转换成二进制**目标代码**p1.o.  
目标代码是机器代码的一种形式,包含所有指令的二进制表示,但是没有填入地址的全局值.  
最后,**链接器**将两个目标文件代码与实现库函数的代码合并,并产生最终的可执行文件.  
###3.2.1 机器级代码
计算机系统使用了多种不同的形式抽象,利用更简单的模型来是隐藏实现的细节.  
对于机器编程来说,两种抽象尤为重要:  
1. 机器级程序的格式和行为,定义为**指令集体系结构**.他定义了处理器状态,指令的格式,以及每条指令对状态的影响.  
2. 机器级程序使用的存储器地址是虚拟地址,提供的存储器模型看上去是一个非常大的字节数组.存储器系统的实现是将多个硬件存货粗气和操作系统软件组合起来.  
一些处理器的介绍:  
1. 程序计数器(pc).指示将要执行的下一条指令在存储器中的地址.  
2. 整数寄存器文件包含8个命名的位置,分别存储32位的值.这些寄存器可以存储地址或整数数据.有的寄存器被用来记录某些重要的程序状态,其他的寄存器用来保存临时数据,例如局部变量和函数的返回值.  
3. 条件码寄存器保存着最近执行的算数或逻辑指令的状态信息.它们用来实现控制或数据流中的条件变化,比如实现if和while语句.  
4. 一组浮点寄存器存放浮点数据.  

 程序存储器包含:程序的可执行机器代码,操作系统需要的一些信息,用来管理过程调用和返回的运行时栈,用户分配的存储器块(malloc).程序存储器用虚拟地址来寻址.在任意给定的时刻,只认为有限的一部分虚拟地址是合法的.操作系统负责管理虚拟地址空间,将虚拟地址翻译成实际处理器存储器中的物理地址.  
 一条机器指令只执行一个非常基本的操作.例如,将存放在寄存器中的两个数字相加,在存储器和寄存器之间传送数据,伙食条件分治转移到新的指令地址.编译器必须产生这些指令的序列,从而实现程序结构.  
 要查看目标文件的内容,可以用**反汇编器**.这些程序根据目标代码产生一种类似于汇编代码的格式.  
##3.3数据格式  
 字表示16位数据类型.称32位数为 双字. int,long int都是双字形式存储的.  
##3.4 访问信息  
 一个IA32 CPU 包含一组8个存储32位值的**寄存器**.用来存储整数数据和指针.  
 eax,ecx,edx..ebx,edi,esi...ebp,esp保存着指向程序栈中重要位置的指针.  
 
###3.4.1操作数指示符
大多数指令有一个或多个**操作数**.操作数分为三种类型:  
1. 立即数.也就是常数值,任何能放进一个32位的字里的数值都可以做立即数.  
2. 寄存器.表示某个寄存器的内容,双字操作eax,字操作ax.对字节操作,可以是8个单字节寄存器中的al.  
3. 存储器引用.它会根据计算出来的地址访问某个存储器位置.  
有多种不同的**寻址方式**,比如:立即数寻址,寄存器寻址,绝对寻址,间接寻址...  
###3.4.2数据传送指令
 MOV指令,将数据从一个位置复制到另一个位置的指令.movb,movw,movl.分别是在1,2,4个字节的数据上进行操作.MOVS,符号扩展,MOVZ,零扩展.  
 第一个是源操作数,第二个是目的操作数.  
 PUSH操作,esp先 -4,然后把eax 赋值到 esp的地址中.  
 POP操作,先把esp地址中的内容 赋值到 eax,然后esp+4.  
 
###3.4.3数据传送
 C语言中所为的"指针"其实就是地址.间接引用指针就是将该指针放在一个寄存器中,然后在存储器引用中使用这个寄存器.局部变量通常也是保存在寄存器中,而不是存储器中.寄存器访问比存储器访问要快得多.  
##3.5算数和逻辑操作
 每个指令类都有对字节,字和双字数据进行操作的指令(b,w,l).这些操作被分为四组:加在有效地址,一元操作,二元操作和移位.元代表操作个数.  
###3.5.1加载有效地址
 **加载有效地址**指令leal实际上是movl指令的变形.它的指令形式是从**存储器读数据到寄存器**,但实际上他根本**没有**引用存储器.它的第一个操作数看上去是一个存储器引用,但该指令并不是从指定的位置读入数据,而是将有效地址写入到目的操作数.  
###3.5.2一元操作和二元操作
 一元操作数,只有一个操作数,即是源又是目的,这个操作数可以是一个寄存器,也可以是一个存储器位置. incl 加一操作.  
 二元操作,源操作数是第一个,目的操作数是第二个,例如,指令subl %eax,%edx. 从edx中减去eax.第一个操作数可以是立即数,寄存器或是存储器位置.第二个操作数可以是寄存器或是存储器位置.但是两个数不能同时是存储器位置.  
###3.5.3移位操作
 先给出移位量,第二项给出要移位的位数.可以进行算数和逻辑右移.移位量用单个字节编码,因为只允许进行0到31位的移位.移位量可以是一个立即数,或者存放在单字节寄存器元素cl中.  
 左移指令 SAL,SHL两者效果一样,都是将右边填上0.  
 右移指令 SAR执行算数移位(填符号位),SHR执行逻辑移位(填0).移位操作的目的操作数可以是一个寄存器或是一个存储器位置.  
###3.5.5特殊的算数操作
 乘法,要求一个参数必须在寄存器 eax中,另一个作为指令的源操作数给出.然后乘积存放在寄存器 edx(高32位)和eax(低32位)中.  
 除法,将寄存器edx和eax中的64位数作为被除数,而除数作为指令的操作数给出.指令将商存储在寄存器eax中,将余数存储在edx中.  
 
##3.6控制
 jump指令可以改变一组机器代码指令的执行顺序,jump指令指定控制应该被传递到哪个其他部分.  
###3.6.1条件码
 除了整数寄存器,CPU还维护着一组单个位的**条件码**寄存器,它们描述了最近的算数或逻辑操作的属性.可以检测这些寄存器来执行条件分支指令.常用的条件码有:  
 CF : 进位标识.最近的操作使最高位产生了进位.可以用来检查无符号操作数的溢出.  
 ZF : 零标识.最近的操作得出的结果为0.  
 SF : 符号标识.最近的操作得到的结果为负数.  
 OF : 溢出标识.最近的操作导致一个补码溢出--正溢出或负溢出.  
  
 CMP指令和TEST指令,只设置条件码而不改变任何其他寄存器.  
###3.6.2访问条件码
 读取使用条件码的三种方法:  
 1. 根据条件码的某个组合,将一个字节设置为0或1, SET指令的目的操作数是8个单字节寄存器元素之一,或是存储一个字节的存储器位置.  
 2. 可以条件跳转到程序的某个其他部分  
 3. 可以有条件地传送数据.  
 
 使用setl(小于时设置)指令,测试一个有符号比较.如果没有发生溢出,当a\<b时,SF设置为1指明这一点.当a>=b,由SF设置为0指明.如果发生溢出,我们有当a-b>0(负溢出)时a\<b,而当a-b\<0(正溢出)时a>b.当a=b时不会有溢出.因此当OF被设置为1时,我们有当且仅当SF被设置为0,有a\<b.把这些情况结合起来,溢出和符号位的EXCLUSIVE-OR提供了a\<b是否为真的测试.其他的有符号比较测试基于SF^OF和ZF的其他组合.  
 对于无符号比较的测试,指令计算t=a-b,当a-b\<0时,CMP指令会设置进位标志,因而无符号使用比较的是进位标志和零标志的组合.  
 
###3.6.3跳转指令及其编码
 正常执行状况,指令按照它们出现顺序逐条执行.**跳转**指令会导致执行切换到程序中一个全新的位置.跳转的目的地通常用一个**标号**指明.  
 跳转指令有几种不同的编码,但是最常用的都是PC相关的.它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码.这些地址偏移量可以编码1,2或4个字节.第二种编码方法是给出"绝对"地址,用4个字节直接指定目标.汇编器和链接器会选择适当的跳转目的编码.  
 当执行与PC相关的寻址时,程序计数器的值是跳转指令后面的那条指令的地址,而不是跳转指令本身的地址.  
###3.6.4翻译条件分支
 实现if语句时,使用cmp进行if中的条件判断,接下来相应的跳转可以用带条件的jmp语句,比如jge(大于等于跳转)来实现相应的跳转.  
 汇编代码首先比较了两个操作数,设置条件码,然后进行跳转.  
 
 
