#第七章 链接  
 **链接(linking)是将各种代码和数据片段手机并组合成为一个单一文件的过程,这个文件可以被**加载**到内存并执行.  
 链接可以执行于**编译**时,也就是在**源代码被翻译成机器代码时**  
 也可以执行于**加载**时,也就是在程序被**加载器加载到内存并执行时**  
 甚至执行于**运行时**,也就是由应用程序来执行.  
 现代系统中,链接是由叫做**链接器**的程序自动执行的.  
 链接器在软件开发中扮演着一个关键的角色,因为它们使得**分离编译**称为可能.可以把一个巨大的源文件分解成更小,更好管理的模块,可以独立地修改和编译这些模块.当改变这些模块中的一个时,只需简单地重新编译它,并重新连接应用,而不必重新编译其他文件.  
 学习链接只是的重要性:  
 **理解链接器帮助你构造大型程序**.构造大型程序的程序员经常会遇到由于缺少模块,缺少库或者不兼容的库版本引起的链接器作物.除非你理解链接器是如何解析引用,什么是库以及链接器是如何使用库来解析引用的,否则这类错误将令你感到迷惑和挫败.(什么鬼东西,不就是缺少文件啊)  
 **理解链接器将帮助你避免一些危险的编程错误**.Linux链接器解析符号引用时所作的决定可以不动声色地影响你程序的正确性.在默认情况下,错误地定义多个全局变量的程序将通过链接器,而不产生任何警告信息.由此得到的程序会产生令人迷惑的运行时行为,而且非常难以调试.(这个好像是C里有的,Java不太清楚)  
 **理解链接将帮助你理解语言的作用于规则是如何实现的**.例如全局和局部变量之间的区别是什么?当你定义一个具有static属性的变量或者函数时,实际到低意味着什么?  
 **理解链接将帮助你理解其他重要的系统概念**.链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色,比如加载和运行程序,虚拟内存,分页,内存映射.  
 **理解链接将使你能够利用共享库**.多年以来,链接都被认为是相当简单和无趣的.然而,随着共享库和动态链接在现代操作系统中重要性的日益加强,链接称为一个复杂的过程,为掌握它的程序员提供了强大的能力.比如,许多软件产品在运行时使用共享库来升级压缩包装的二进制程序.还有,大多数Web服务器都依赖于共享库的动态链接来提供动态内容.  
 这一章讨论基于这样的环境:一个运行Linux的xo6-64系统,使用标准的ELF-64目标文件格式.但是基本的链接概念是通用的,细节可能不尽相同,但是概念是相同的.  
 
##7.1 编译器驱动程序
```
 int sum(int *a, int n);
 
 int array[2] = {1,2};
 
 int main()
 {
    int val = sum(array, 2);
    return val;
 }
 
 main.c 文件
```
 
```
 int sum(int *a, int n)
 {
    int i, s = 0;
    
    for(i = 0; i < n; i++){
      s += a[i];
    }
    return s;
 }
 
 sum.c 文件
```
 大多数编译系统提供**编译器驱动程序(compiler driver)**,它代表用户在需要时调用语言预处理器,编译器,汇编器和链接器.比如,要用GNU编译系统构造示例程序,就需要在shell中输入下列命令  
 linue > gcc -Og -o prog main.c sum.c  
 驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件时的行为.  
 驱动程序首先运行C预处理器(CPP),它将C的源程序main.c翻译成一个ASCII码的中间文件main.i :  
 cpp [other arguments] main.c /tmp/main.i  
 接下来,驱动程序运行C编译器(ccl),它将main.i翻译成一个ASCII汇编语言文件main.s :  
 ccl /tmp/main.i -Oo [other arguments] -o /tmp/main.s  
 然后,驱动程序运行汇编器(as),它将main.s翻译成一个**可重定位目标文件(relocatable object file)main.o:  
 as [other arguments] -o /tmp/main.o /tmp/main.s  
 驱动程序经过相同的过程生成sum.o.最后,它运行连接器程序 ld,将main.o 和sum.o 以及一些必要的系统目标文件组合起来,创建一个**可执行目标文件(executable object file)prog:  
 ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o  
 要运行可执行文件prog. 在Linux shell的命令行中输入它的名字:  
 linux> ./prog  
##7.2静态链接
 像Linux LD程序这样的**静态链接器(static linker)**以一组可重定位目标文件和命令行参数作为输入,生成一个完全链接的,可以加载和运行的可执行目标文件作为输出.输入的可重定位目标文件由各种不同的代码和数据节(section)组成,每一节都是一个连续的字节序列.指令在一节中,初始化了的全局变量在另一节中,而未初始化的变量又在另外一节中.  
 为了构造可执行文件,链接器必须完成两个主要任务.  
 **符号解析(symbol resolution)**.目标文件定义和引用符号.每个符号对应于一个函数,一个全局变量或一个静态变量.符号解析的目的是**将每个符号引用正好和一个符号定义关联起来**  
 **重定位(relocation)**.编译器和汇编器生成从地址0开始的代码和数据结构.**链接器通过把每个符号定义与一个内存位置关联起来,从而重定位这些节,然后修改所有对这些符号的引用,使得它们指向这个内存位置**.链接器使用汇编器产生的重定位条目(relocation entry)的详细指令,不加甄别地执行这样的重定位.  
##7.3 目标文件
 目标文件三种形式:  
 **可重定位目标文件**.包含二进制代码和数据,其形式可以在编译时与其他可重定位目标文件合并起来,创建一个可执行目标文件.  
 **可执行目标文件**.包含二进制代码和数据,其形式可以呗直接复制到内存并执行.  
 **共享目标文件**.一种特殊类型的可重定位目标文件,可以在加载或者运行时被动态地加载进内存并链接.  
 编译器和汇编器生成可重定位目标文件(包括共享目标文件).链接器生成可执行目标文件.一个**目标模块**就是一个字节序列,而一个**目标文件**就是一个以文件形式存放在磁盘中的目标模块.  
##7.4 可重定位目标文件  
 ELF头和节头部表之间的都是借.一个典型的ELF可重定位目标文件包含下面几个节:  
 <ul>
 <li>.text: 已编译程序的机器代码</li>
 <li>.rodata: 制度数据,比如printf语句中的格式串和开关语句的跳转表.</li>
 <li>.data: 已初始化的全局和静态C变量.局部C变量在运行时被保存在栈中,既不出现在.data节中,也不出现在.bss节中</li>
 <li>.bss: 未初始化的全局和静态C变量,以及所有被初始化为0的全局或静态变量.在目标文件中这个节不占据实际的空间,它仅仅是一个占位符.目标文件格式区分已初始化和未初始化变量时为了空间效率:在目标文件中,未初始化变量不需要占据任何实际的磁盘空间.运行时,在内存中分配这些变量,初始值位0.</li>
 <li>.symtab: 一个符号表,它存放在程序中定义和引用的函数和全局变量的信息.每个可重定位目标文件在.symtabl中都有一张符号表.然而,和编译器中的符号表不同,.symtab符号表不包含局部变量的条目.</li>
 <li>.rel.text: 一个.text节中位置的列表,当链接器把这个目标文件和其他文件组合时,需要修改这些位置.</li>
 <li>.real.data: 被模块引用或定义的所有全局变量的重定位信息.一般而言,任何已初始化的全局变量,如果他的初始值是一个全局变量地址后者外部定义函数的地址,都需要被修改.</li>
 <li>.debug: 一个调试符号表,其条目是程序中定义的局部变量和类型定义,程序中定义和引用的全局变量,以及原始的C源文件.</li>
 <li>.line: 原始C源程序中的行号和.text节中机器指令之间的映射.</li>  
 <li>.strtab: 一个字符串表,其内容包括.symtab 和 .debug节中的符号表,以及节头部中的节名字.字符串表就是以null结尾的字符串的序列.</li>
 </ul>
##7.5 符号和符号表
 每个可重定位目标模块m都有一个符号表,它包括m定义和引用的符号的信息.在链接器的上下文中,有三种不同的符号:  
 <ul>
 <li>由模块m定义并能被其他模块引用的全局符号.全局链接器符号对应于非静态的c函数和全局变量.</li>
 <li>由其他模块定义并被模块m引用的全局符号.这些符号称为外部符号,对应于在其他模块中定义的非静态C函数和全局变量.</li>
 <li>只被模块m定义和引用的局部符号.它们对应于带static属性的C函数和全局变量.</li>
 </ul>
 认识到本地连机器符号和本地程序变量不同是很重要的..symtab中的符号表**不包含对应于本地非静态程序变量的任何符号.**这些符号在运行时在栈中被管理,连机器对此类符号不感兴趣.  
 定义为带有C static属性的本地过程变量是不在栈中管理的.相反,编译器在.data或.bss中为每个定义分配空间,并在符号表中创建一个有唯一名字的本地链接器符号.比如,假设在同一模块中的两个函数工资定义了一个静态局部变量x:  
 ```
 int f()
 {
    static int x = 0;
    return x;
 }
 
 int g()
 {
     static int x = 1;
     return x;
 }
 ```
 在这种情况下,编译器向汇编器输出两个不同名字的局部链接器符号.比如,可以用x.1表示函数f中的定义,而用x.2表示函数g中的定义.  
 符号表是由汇编器构造的,使用编译器输出到汇编语言.s文件中的符号. .symtab节中包含ELF符号表.这张符号表包含一个条目的数组.格式如下:  
 ```
 typedef struct {
     int name;             /* String table offset */
     char type:4,          /* Function or data (4 bits) */
          binding:4;       /* Local or global (4 bits) */
     char reserved;        /* Unused*/
     short section;        /* Section header index */
     long value;           /* Section offset or absolute address */
     long size;            /* Object size in bytes */
 }Elf64_Symbol;         
 ```
 name是字符串中的字节偏移,指向符号的以null结尾的字符串名字.  
 value是符号的地址.对于可重定位目标来说,value是距定义目标的节的起始位置的偏移;对于可执行文件,就是绝对运行时地址.  
 size是目标的大小,以字节为单位.  
 type通常要么是数据,要么是函数.  
 符号表还包含各个节的条目,以及对应原始源文件的路径名的条目.所以这些目标的类型也有所不同.binding字段表示符号是本地的还是全局的.  
 每个符号都被分配到目标文件的某个节,由section字段表示,该字段也是一个到节头部表的索引.有三个特殊的伪节,它们在节头部表中是没有条目的:  
 ABS代表不该被重定位的符号;  
 UNDEF代表未定义的符号,也就是在本目标模块中引用,但是却在其他地方定义的符号;  
 COMMON表示还未被分配位置的未初始化的数据目标.  
 对于COMMON符号,value字段给出对齐要求,size给出最小的大小.注意,**只有可重定位目标中才有这些伪节,课执行目标文件中是没有的.**  
 现代的GCC版本根据以下规则来将可重定位目标文件中的符号分配到COMMON和.bss中:  
 COMMON 未初始化的全局变量  
 .bss 未初始化的静态变量,以及初始化为0的全局或静态变量.  
  
##7.6符号解析  
 链接器解析符号引用的方法是将每个引用于它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来.  
 不过,对全局符号的引用解析就棘手一些.当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时,会假设该符号是在其他某个模块中定义的,生成一个链接器符号表条目,并把它交给链接器处理.如果链接器在它的任何输入模块中都找不到这个被引用符号的定义,就会输出一条错误信息并终止.  
###7.6.1链接器如何解析多重定义的全局符号
 链接器的输入是**一组**可重定位目标模块.每个模块定义一组符号,有些是局部的(只对定义该符号的模块可见),有些事全局的.如果多个模块定义同名的全局符号,会发送什么呢?  
 编译时,编译器向汇编器输出每个全局符号,或是强或者是弱,而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里.  
 **函数和已初始化的全局变量是强符号,未初始化的全局变量是弱符号.**  
 根据强弱符号的定义,Linux链接器使用下面的规则来处理多重定义的符号名:  
 1: 不允许有多个同名的强符号.  
 2: 如果有一个强符号和多个弱符号同名,选择强符号.  
 3: 如果有多个弱符号同名,那么从这些弱符号任意选择一个.  
 **根据规则2和规则3的应用会造成一些不易察觉的运行时错误,比如下面的例子,其中x不幸的在一个模块中定义为int,而在另一个模块中定义为double.**  
 ```
 /* foo5.c */
 #include <stdio.h>
 void f(void);
 
 int y = 1512;
 int x =15213;
 
 int main()
 {
    f();
    printf("x = 0x%x y = 0x%x \n",x,y);
    return 0;
 }
 
 /* bar5.c */
 double x;
 void f()
 {
    x = -0.0;
 }
 ```
 在一台 x86-64 /Linux机器上,double类型是8个字节,而int类型是4个字节.在我们的系统中,x的地址是0x601024.因此,bar5.传递第六行中的复制 x=-0.0将用负零的**双精度浮点**表示覆盖内存中x和y的位置.  
 x = 0x0 y = 0x80000000  
 当编译器在翻译某个模块时,遇到一个弱全局符号,比如x,它并不知道其他模块是否也定义了x,如果是,它无法预测链接器该使用x的多重定义中的哪一个.所以编译器把x分配成COMMON,把决定权留给链接器.另一方面,如果x初始化为0,那么它是一个强符号,所以编译器可以很自信地将它分配成.bss.类似的,静态符号的构造就必须是唯一的,所以编译器可以自信地把它们分配成.data或.bss.  
###7.6.2 与静态库链接
 迄今为止,都是假设链接器读取一组可重定位目标文件,并把它们连接起来,形成一个输出的可执行文件.实际上,所有的编译系统都提供了一种机制,将所有相关的目标模块打包成一个单独的文件,称为**静态库**,它可以用作链接器的输入.当链接器构造一个输出的可执行文件时,它只是复制静态库里被应用程序引用的目标模块.  
 如果不使用静态库,如果要向用户提供这些函数,一种方法是**让编译器辨认出对标准函数的调用,并直接生成相应的代码.**而且每次添加,删除或修改一个标准函数时就需要一个新的编译器版本.  
 另一种方法是**将所有的标准C函数都放在一个单独的可重定位目标模块中**.优点是它将编译器的实现和标准函数的实现分离开来,并且仍然对程序员保持适度的便利.一个很大的缺点是,系统中每个可执行文件现在都包含着一份标准函数集合的完全副本,这对磁盘空间是很大的浪费.更糟糕的是,每个正在运行的程序都将它自己的这些函数的副本放在内存中,这是对内存的极度浪费.另一个大的缺点是,对任何标准函数的任何改变,无论多么小的改变,都要求库的开发人员重新编译整个源文件,这是一个非常耗时的操作,使得标准函数的开发和维护变得很复杂.  
 可以通过为每个标准函数创建一个独立的可重定位文件,解决这个问题,然而这个方法要求 应用程序员显示地链接合适的目标模块到它们的可执行文件中.(链接一大堆 xx.o)  
 **静态库**概念被提出来,可以解决这些不同方法的缺点.相关的函数可以被编译为独立的目标模块,然后封装成一个单独的静态库文件.应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数.  
 在链接时,链接器将**只复制被程序引用的目标模块**,也就减少了可执行文件在磁盘和内存中的大小(没有把所有的函数导入).应用程序员只需要用较少的库的名字即可.  
 静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中,存档文件是一组链接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置.存档文件名由.a标识.  
###7.6.3 链接器如何使用静态库来解析引用
 Linux链接器使用它们解析外部引用的方式.在符号解析阶段,链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件.  
 链接器在扫描中维护一个可重定位目标文件的集合E(这个集合中的文件会被合并起来形成可执行文件),一个**未解析符号(引用了但是尚未定义的符号)的集合U**,以及一个在前面输入文件中已定义的符号集合D.初始时,E,U,D均为空.  
 对于命令行上的每个输入文件f,链接器会判断f是一个目标文件还是一个存档文件,如果是目标文件,链接器会把f添加到E,修改U和D来反应f的符号定义和引用,继续下一个文件.  
 如果f是一个存档文件,链接器尝试匹配U中未解析的符号和由存档文件成员定义的符号.如果某个存档文件成员m,定义了一个符号来解析U中的一个引用,就将m添加到E中,并且链接器修改U和D来反应m中的符号定义和引用.  
 如果当链接器完成对命令行上输入文件的扫描后,U是非空的,那么链接器就会输出一个错误并终止.  
 关于库的一般准则是将它们放在命令行的结尾,如果库不是相互独立的,必须对它们排序.  
##7.7 重定位
 一旦链接器完成了符号解析这一步,就把代码中的每个符号引用和正好一个符号定义关联起来.此时,链接器就知道他的输入目标模块中的代码节和数据节的确切大小.现在可以开始重定位步骤.**在这个步骤中,将合并输入模块,并为每个符号分配运行时地址**.重定位由两步组成:  
 + **重定位节和符号定义**.来自所有输入模块的.data节被全部合并成一个节,这个节称为输出的可执行文件的.data节.然后链接器将运行时内存地址赋给新的聚合节,赋给输入模块定义的每个节,以及赋给输入模块定义的每个符号.当这一步完成时,程序中的每条指令和全局变量都有唯一的运行时内存地址了.  
 + **中定位节中的符号引用**.链接器修改代码节和数据节中对每个符号的引用.使得它们指向正确的运行时地址.要执行这一步,链接器依赖于**可重定位目标模块中称为重定位条目(relocation entry)**的数据结构.  
  
###7.7.1 重定位条目
 无论何时**汇编器**遇到对最中位置未知的目标引用,它就会生成一个**重定位条目**,告诉链接器在将目标文件合并成可执行文件时如何修改这个引用.代码的重定位条目放在.rel.text中.已初始化数据的重定位条目放在.rel.data中.  
 ```
 ELF重定位条目的格式
 
 typedef struct {
     long offset;
     long type:32,
          symbol:32;
     long addend;
 }
 ```
 offset是需要被修改的引用的节偏移.symbol标识被修改引用应该指向的符号.  
 type告诉链接器如何修改新的引用.addend是一个有符号常熟,一些类型的重定位要使用它对被修改引用的值做偏移调整.  
###7.7.2 重定位符号引用
 **1.重定位PC相对引用..P480**  
 **2.重定位绝对引用..P481**  
##7.8 可执行目标文件
 可执行目标文件的格式类似于可重定位目标文件的格式.它包括程序的**入口点(entry point)**.也就是当程序运行时要执行的第一条指令的地址.  
 ELF可执行文件被设计得很容易加载到内存,可执行文件的连续的片被映射到连续的内存段.程序头部表描述了这种映射关系.  
 ```
 Read-only code segment
 LOAD off    0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21
      filesz 0x000000000000069c memsz 0x000000000000069c flags r-x
      
 Read/write data segment
 LOAD off    0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align 2**21
      filesz 0x0000000000000228 memsz 0x0000000000000230 flags rw-
 ```
 + off:目标文件中的偏移;  
 + vaddr/paddr:内存地址;  
 + align:对齐要求;  
 + filesz: 目标文件中的段大小;  
 + memsz: 内存中的段大小;  
 + flags: 运行时访问权限.  
对于任何数据段s,链接器必须选择一个起始地址vaddr,使得  
 vaddr mod align = off mod align  
 这个对齐要求是一种优化,使得当程序执行时,目标文件的段能够很有效率地传送到内存中.在于虚拟内存的祖师方式,它被组织成一些很大的,连续的,大小为2的幂的字节片  
 
##7.9 加载可执行目标文件  
 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中,然后通过跳转到程序的第一条指令或入口点来运行程序.这个将程序复制到内存并运行的过程叫加载.  
 在Linux x86-64系统中,代码段总是从地址 0x400000处开始,后面是数据段,运行时堆在数据段之后,通过调用malloc库网上增长.堆后面的区域是为共享模块保留的.用户栈总是从最大的合法用户地址(2<sup>48</sup>-1)开始,向较小内存地址增长.  
 在分配栈,共享库和堆运行时地址的时候,链接器还会使用**地址空间布局随机化(防止被改程序,毁坏本机器)**.虽然每次程序运行时这些区域的地址都会改变,它们的相对位置是不变的.  
 当加载器运行时,在程序头部表的引导下,加载器将可执行文件的片复制到代码段和数据段.接下来,加载器跳转到程序的入口点,也就是start函数的地址.它将初始化执行环境,调用用户层的main函数.  
***
 **加载器实际是如何工作的?**  
 之前对于加载的描述从概念上来说是正确的,但也不是完全准确.要理解加载实际是如何工作的,必须理解进程,虚拟内存和内存映射的概念.  
 实际工作的一个概述:  
 Linux系统中的每个程序都运行在一个进程上下文中,有自己的虚拟地址空间.当shell运行一个程序时,父shell进程生成一个紫禁城,它是父进程的一个复制.子进程通过execve系统调用启动加载器.加载器删除子进程现有的虚拟内存段,并创建一组新的代码,数据,堆和栈段.新的栈和堆段被初始化为零.通过将虚拟地址空间中的页映射到可执行文件的页大小的片,新的代码和数据段被初始化为可执行文件的内容.最后,加载器跳转到start地址,它最终会调用应用程序的main函数.出了一些头部信息,在加载过程中没有任何从磁盘到内存的数据复制.直到CPU引用一个被映射的虚拟页时才会进行复制,此时,操作系统利用它的页面调度机制自动将页面从磁盘传送到内存.  
##7.10 动态链接共享库
 静态库解决了许多关于如何让大量相关函数对应用程序可用的问题,然而,静态库仍然有一些明显的缺点.  
 静态库和所有的软件一样,需要定期维护和更新.如果应用程序员想要使用一个库的最新版本,他们必须以某种方式了解到该库的更新情况,然后显式地将他们的程序和更新了的库重新链接.  
 几乎每个C程序都使用标准I/O函数,比如printf 和 scanf.在运行时,这些函数的代码会复制到每个运行进程的文本段中.在一个运行上百个进程的典型系统上,这将是对稀缺的内存系统资源的极大浪费.  
 **共享库**是致力于解决静态库缺陷的一个现代创新产物.共享库是一个目标模块,在运行或加载时,可以加载到任意的内存地址,并和一个在内存中的程序链接起来,这个过程称为动态链接.是由一个叫**动态链接器**的程序来执行.共享库也称为共享目标,在Linux系统中通常用.so后缀.微软操作系统中,称为DLL(动态链接库)  
 共享库是以两种不同的方式来共享的.  
 首先,在任何给定的文件系统中,对于一个库只有一个.so文件.所有引用该库的可执行目标文件共享这个.so文件中的代码和数据,而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中.  
 其次,在内存中,一个共享库的.text节的一个副本可以被不同的正在运行的进程共享.  
 基本思路是,当创建可执行文件时,静态执行一些链接,然后在程序加载时,动态完成链接过程.认识这一点很重要:**此时,没有任何lib.so的代码和数据节真的被复制到可执行文件prog2l中.**反之,链接器复制了一些**重定位和符号表信息**,它们使得运行时可以解析对lib.so中代码和数据的引用.(**主要是 引用的思想 感觉和指针有点像 只保存了地址 而不是实际内容 节省空间**)  
 当加载器加载时,加载器不会像它通常所作地那样将控制传递给应用,而是加载和运行这个动态链接器.然后动态链接器通过执行下面的**重定位**完成链接任务:  
 + 重定位 libc.so的文本和数据到某个内存段  
 + 重定位 lib.so的文本和数据到另一个内存段  
 + 重定位 prog2中所有对由libc.so和lib.so定义的符号的引用.  
最后,动态链接器将控制传递给应用程序.从这个时刻开始,共享库的位置就固定了,并且在程序执行的过程中都不会改变.  
##7.11 从应用程序加载和链接共享库  
 **分发软件**  
 Windows应用的开发者常常利用共享库来分发软件更新.他们生成一个共享库的新版本,然后用户可以下载,并用它替换当前的版本.下一次他们运行应用程序时,应用将自动连接和加载新的共享库.  
 **构建高性能Web服务器**  
 许多Web服务器生成动态内容,比如个性化的Web页面,账户余额和广告标语.早期的Web服务器通过使用fork和exevce创建一个子进程,并在该子进程的上下文中运行CGI程序来生成动态内容.然而,现代高性能的Web服务器可以使用基于动态链接的更有效和完善的方法来生成动态内容.
 思路是,将每个生成动态内容的函数打包在共享库.当一个来自web浏览器的请求到达时,服务器动态地加载和链接适当的函数,然后调用它,而不是使用fork和execve在子进程的上下文中运行函数.函数会一直缓存在服务器的地址空间,所以只要一个简单的函数调用的开销就可以处理随后的请求了.这对一个繁忙的网站来说是由很大影响的.更进一步说,在运行时无需停止服务器,就可以更新已存在的函数,以及添加新的函数.  
##7.12 位置无关代码
 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码,因而节约宝贵的内存资源.  
 多个进程如何共享程序的一个副本?  
 给每个共享库分配一个事先预备好的专用的地址空间片,然后要求加载器总是在这个地址加载共享库.虽然这个方法简单,但是,它对地址空间的使用效率不高,因为即使一个进程不实用这个库,那这部分空间还是会被分配出来.它也难以管理.每次当一个库修改之后,必须确认已分配给它的片还适合它的大小.如果创建一个新的库,还要为它寻找空间.  
 要避免这些问题,现代系统以这样一种方式编译共享模块的代码段,使得可以把它们加载到内存的任何位置而无需链接器修改.使用这种方法,无限多个进程可以共享一个共享模块的代码段的单一副本.  
 可以加载而无需重定位的代码称为**位置无关代码**  
 **1. PIC数据引用**  
 无论我们在内存中何处加载一个目标模块(包括共享目标模块),数据段与代码段的距离总是保持不变,因此,代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量,与代码段和数据段的绝对内存位置是无关的.  
 想要生成对全局变量PIC引用的编译器利用了这个事实,它在数据段开始的地方创建了一个表,叫做**全局偏移量表(Global Offset Table,GOT)**.在GOT中,每个被这个目标模块引用的全局数据目标(过程或全局变量)都有一个8字节条目.编译器还为GOT中每个条目生成一个重定位记录.在加载时,动态链接器会重定位GOT的每个条目,使得它包含目标的正确的绝对地址.每个引用全局目标的目标模块都有自己的GOT.  
 编译器可以利用代码段和数据段之间不变的距离,产生对addcnt的直接PC相对引用,并增加一个重定位,让链接器在构造这个共享模块时解析它,如果addcnt是另一个共享模块定义的,那么就需要通过GOT进行简介访问. (P490)  
 **2.PIC函数调用**  
 假设程序调用一个由共享库定义的函数.编译器没有办法预测这个函数的运行时地址.因为定义它的共享模块在运行时可以加载到任意位置.正常的方法是为该引用生成一条重定位记录,然后动态链接器在程序加载的时候再解析它.不过这种方法并不是PIC,因为它需要链接器修改调用模块的代码段,GNU编译系统使用了**延迟绑定(lazy binding)**将过程地址的绑定推迟到第一调用该过程时.  
 使用延迟绑定的动机是对于一个像libc.so的共享库输出的成百上千函数中,一个典型的应用程序只会使用其中很少的一部分.吧函数地址的解析推迟到它实际被调用的地方,能避免动态链接器在加载时进行成百上千个其实不需要的从定位.第一次调用过程的运行时开销很大,但是其后的每次调用都只会花费一条指令和一个间接的内存引用.
 
 延迟绑定通过 GOT和 过程连接表(Procedure Linkage Table, PLT).如果**一个目标模块调用定义在共享库中的任何函数,那么它就有自己的GOT和PLT.**GOT是数据段的一部分,PLT是代码段的一部分.  
 + 过程链接表(PLT).PLT是一个数组,其中每个条目是16字节代码.每个被可执行程序调用的库函数都有自己的PLT条目.PLT[0]是一个特殊条目,它跳转到动态链接器中.每个条目都负责调用一个具体的函数.
 + 全局偏移量表(GOT).GOT是一个数组,每个条目是8字节地址.和PLT联合使用.GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息.GOT[2]是动态链接器在ld-linux.so模块中的入口点.其余的每个条目对应于一个被调用的函数,地址需要在运行时被解析.每个条目都有一个相匹配的PLT条目.(P491)  
##7.13 库打桩机制
 Linux链接器支持一个很强大的技术,称为库打桩,允许你截获对共享库函数的调用,取而代之执行自己的代码.(不想写了...编译,加载,运行时打桩)  
 
