#第七章 链接  
 **链接(linking)是将各种代码和数据片段手机并组合成为一个单一文件的过程,这个文件可以被**加载**到内存并执行.  
 链接可以执行于**编译**时,也就是在**源代码被翻译成机器代码时**  
 也可以执行于**加载**时,也就是在程序被**加载器加载到内存并执行时**  
 甚至执行于**运行时**,也就是由应用程序来执行.  
 现代系统中,链接是由叫做**链接器**的程序自动执行的.  
 链接器在软件开发中扮演着一个关键的角色,因为它们使得**分离编译**称为可能.可以把一个巨大的源文件分解成更小,更好管理的模块,可以独立地修改和编译这些模块.当改变这些模块中的一个时,只需简单地重新编译它,并重新连接应用,而不必重新编译其他文件.  
 学习链接只是的重要性:  
 **理解链接器帮助你构造大型程序**.构造大型程序的程序员经常会遇到由于缺少模块,缺少库或者不兼容的库版本引起的链接器作物.除非你理解链接器是如何解析引用,什么是库以及链接器是如何使用库来解析引用的,否则这类错误将令你感到迷惑和挫败.(什么鬼东西,不就是缺少文件啊)  
 **理解链接器将帮助你避免一些危险的编程错误**.Linux链接器解析符号引用时所作的决定可以不动声色地影响你程序的正确性.在默认情况下,错误地定义多个全局变量的程序将通过链接器,而不产生任何警告信息.由此得到的程序会产生令人迷惑的运行时行为,而且非常难以调试.(这个好像是C里有的,Java不太清楚)  
 **理解链接将帮助你理解语言的作用于规则是如何实现的**.例如全局和局部变量之间的区别是什么?当你定义一个具有static属性的变量或者函数时,实际到低意味着什么?  
 **理解链接将帮助你理解其他重要的系统概念**.链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色,比如加载和运行程序,虚拟内存,分页,内存映射.  
 **理解链接将使你能够利用共享库**.多年以来,链接都被认为是相当简单和无趣的.然而,随着共享库和动态链接在现代操作系统中重要性的日益加强,链接称为一个复杂的过程,为掌握它的程序员提供了强大的能力.比如,许多软件产品在运行时使用共享库来升级压缩包装的二进制程序.还有,大多数Web服务器都依赖于共享库的动态链接来提供动态内容.  
 这一章讨论基于这样的环境:一个运行Linux的xo6-64系统,使用标准的ELF-64目标文件格式.但是基本的链接概念是通用的,细节可能不尽相同,但是概念是相同的.  
 
##7.1 编译器驱动程序
```
 int sum(int *a, int n);
 
 int array[2] = {1,2};
 
 int main()
 {
    int val = sum(array, 2);
    return val;
 }
 
 main.c 文件
```
 
```
 int sum(int *a, int n)
 {
    int i, s = 0;
    
    for(i = 0; i < n; i++){
      s += a[i];
    }
    return s;
 }
 
 sum.c 文件
```
 大多数编译系统提供**编译器驱动程序(compiler driver)**,它代表用户在需要时调用语言预处理器,编译器,汇编器和链接器.比如,要用GNU编译系统构造示例程序,就需要在shell中输入下列命令  
 linue > gcc -Og -o prog main.c sum.c  
 驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件时的行为.  
 驱动程序首先运行C预处理器(CPP),它将C的源程序main.c翻译成一个ASCII码的中间文件main.i :  
 cpp [other arguments] main.c /tmp/main.i  
 接下来,驱动程序运行C编译器(ccl),它将main.i翻译成一个ASCII汇编语言文件main.s :  
 ccl /tmp/main.i -Oo [other arguments] -o /tmp/main.s  
 然后,驱动程序运行汇编器(as),它将main.s翻译成一个**可重定位目标文件(relocatable object file)main.o:  
 as [other arguments] -o /tmp/main.o /tmp/main.s  
 驱动程序经过相同的过程生成sum.o.最后,它运行连接器程序 ld,将main.o 和sum.o 以及一些必要的系统目标文件组合起来,创建一个**可执行目标文件(executable object file)prog:  
 ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o  
 要运行可执行文件prog. 在Linux shell的命令行中输入它的名字:  
 linux> ./prog  
##7.2静态链接
 像Linux LD程序这样的**静态链接器(static linker)**以一组可重定位目标文件和命令行参数作为输入,生成一个完全链接的,可以加载和运行的可执行目标文件作为输出.输入的可重定位目标文件由各种不同的代码和数据节(section)组成,每一节都是一个连续的字节序列.指令在一节中,初始化了的全局变量在另一节中,而未初始化的变量又在另外一节中.  
 为了构造可执行文件,链接器必须完成两个主要任务.  
 **符号解析(symbol resolution)**.目标文件定义和引用符号.每个符号对应于一个函数,一个全局变量或一个静态变量.符号解析的目的是**将每个符号引用正好和一个符号定义关联起来**  
 **重定位(relocation)**.编译器和汇编器生成从地址0开始的代码和数据结构.**链接器通过把每个符号定义与一个内存位置关联起来,从而重定位这些节,然后修改所有对这些符号的引用,使得它们指向这个内存位置**.链接器使用汇编器产生的重定位条目(relocation entry)的详细指令,不加甄别地执行这样的重定位.  
##7.3 目标文件
 目标文件三种形式:  
 **可重定位目标文件**.包含二进制代码和数据,其形式可以在编译时与其他可重定位目标文件合并起来,创建一个可执行目标文件.  
 **可执行目标文件**.包含二进制代码和数据,其形式可以呗直接复制到内存并执行.  
 **共享目标文件**.一种特殊类型的可重定位目标文件,可以在加载或者运行时被动态地加载进内存并链接.  
 编译器和汇编器生成可重定位目标文件(包括共享目标文件).链接器生成可执行目标文件.一个**目标模块**就是一个字节序列,而一个**目标文件**就是一个以文件形式存放在磁盘中的目标模块.  
##7.4 可重定位目标文件  
 ELF头和节头部表之间的都是借.一个典型的ELF可重定位目标文件包含下面几个节:  
 <ul>
 <li>.text: 已编译程序的机器代码</li>
 <li>.rodata: 制度数据,比如printf语句中的格式串和开关语句的跳转表.</li>
 <li>.data: 已初始化的全局和静态C变量.局部C变量在运行时被保存在栈中,既不出现在.data节中,也不出现在.bss节中</li>
 <li>.bss: 未初始化的全局和静态C变量,以及所有被初始化为0的全局或静态变量.在目标文件中这个节不占据实际的空间,它仅仅是一个占位符.目标文件格式区分已初始化和未初始化变量时为了空间效率:在目标文件中,未初始化变量不需要占据任何实际的磁盘空间.运行时,在内存中分配这些变量,初始值位0.</li>
 <li>.symtab: 一个符号表,它存放在程序中定义和引用的函数和全局变量的信息.每个可重定位目标文件在.symtabl中都有一张符号表.然而,和编译器中的符号表不同,.symtab符号表不包含局部变量的条目.</li>
 <li>.rel.text: 一个.text节中位置的列表,当链接器把这个目标文件和其他文件组合时,需要修改这些位置.</li>
 <li>.real.data: 被模块引用或定义的所有全局变量的重定位信息.一般而言,任何已初始化的全局变量,如果他的初始值是一个全局变量地址后者外部定义函数的地址,都需要被修改.</li>
 <li>.debug: 一个调试符号表,其条目是程序中定义的局部变量和类型定义,程序中定义和引用的全局变量,以及原始的C源文件.</li>
 <li>.line: 原始C源程序中的行号和.text节中机器指令之间的映射.</li>  
 <li>.strtab: 一个字符串表,其内容包括.symtab 和 .debug节中的符号表,以及节头部中的节名字.字符串表就是以null结尾的字符串的序列.</li>
 </ul>
 ##7.5 符号和符号表
