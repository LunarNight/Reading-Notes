#第七章 链接  
 **链接(linking)是将各种代码和数据片段手机并组合成为一个单一文件的过程,这个文件可以被**加载**到内存并执行.  
 链接可以执行于**编译**时,也就是在**源代码被翻译成机器代码时**  
 也可以执行于**加载**时,也就是在程序被**加载器加载到内存并执行时**  
 甚至执行于**运行时**,也就是由应用程序来执行.  
 现代系统中,链接是由叫做**链接器**的程序自动执行的.  
 链接器在软件开发中扮演着一个关键的角色,因为它们使得**分离编译**称为可能.可以把一个巨大的源文件分解成更小,更好管理的模块,可以独立地修改和编译这些模块.当改变这些模块中的一个时,只需简单地重新编译它,并重新连接应用,而不必重新编译其他文件.  
 学习链接只是的重要性:  
 **理解链接器帮助你构造大型程序**.构造大型程序的程序员经常会遇到由于缺少模块,缺少库或者不兼容的库版本引起的链接器作物.除非你理解链接器是如何解析引用,什么是库以及链接器是如何使用库来解析引用的,否则这类错误将令你感到迷惑和挫败.(什么鬼东西,不就是缺少文件啊)  
 **理解链接器将帮助你避免一些危险的编程错误**.Linux链接器解析符号引用时所作的决定可以不动声色地影响你程序的正确性.在默认情况下,错误地定义多个全局变量的程序将通过链接器,而不产生任何警告信息.由此得到的程序会产生令人迷惑的运行时行为,而且非常难以调试.(这个好像是C里有的,Java不太清楚)  
 **理解链接将帮助你理解语言的作用于规则是如何实现的**.例如全局和局部变量之间的区别是什么?当你定义一个具有static属性的变量或者函数时,实际到低意味着什么?  
 **理解链接将帮助你理解其他重要的系统概念**.链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色,比如加载和运行程序,虚拟内存,分页,内存映射.  
 **理解链接将使你能够利用共享库**.多年以来,链接都被认为是相当简单和无趣的.然而,随着共享库和动态链接在现代操作系统中重要性的日益加强,链接称为一个复杂的过程,为掌握它的程序员提供了强大的能力.比如,许多软件产品在运行时使用共享库来升级压缩包装的二进制程序.还有,大多数Web服务器都依赖于共享库的动态链接来提供动态内容.  
 这一章讨论基于这样的环境:一个运行Linux的xo6-64系统,使用标准的ELF-64目标文件格式.但是基本的链接概念是通用的,细节可能不尽相同,但是概念是相同的.  
 
##7.1 编译器驱动程序
```
 int sum(int *a, int n);
 
 int array[2] = {1,2};
 
 int main()
 {
    int val = sum(array, 2);
    return val;
 }
 
 main.c 文件
```
 
```
 int sum(int *a, int n)
 {
    int i, s = 0;
    
    for(i = 0; i < n; i++){
      s += a[i];
    }
    return s;
 }
 
 sum.c 文件
```
 大多数编译系统提供**编译器驱动程序(compiler driver)**,它代表用户在需要时调用语言预处理器,编译器,汇编器和链接器.比如,要用GNU编译系统构造示例程序,就需要在shell中输入下列命令  
 linue > gcc -Og -o prog main.c sum.c  
 驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件时的行为.  
 驱动程序首先运行C预处理器(CPP),它将C的源程序main.c翻译成一个ASCII码的中间文件main.i :  
 cpp [other arguments] main.c /tmp/main.i  
 接下来,驱动程序运行C编译器(ccl),它将main.i翻译成一个ASCII汇编语言文件main.s :  
 ccl /tmp/main.i -Oo [other arguments] -o /tmp/main.s  
 然后,驱动程序运行汇编器(as),它将main.s翻译成一个**可重定位目标文件(relocatable object file)main.o:  
 as [other arguments] -o /tmp/main.o /tmp/main.s  
 驱动程序经过相同的过程生成sum.o.最后,它运行连接器程序 ld,将main.o 和sum.o 以及一些必要的系统目标文件组合起来,创建一个**可执行目标文件(executable object file)prog:  
 ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o  
 要运行可执行文件prog. 在Linux shell的命令行中输入它的名字:  
 linux> ./prog  
##7.2静态链接
 像Linux LD程序这样的**静态链接器(static linker)**以一组可重定位目标文件和命令行参数作为输入,生成一个完全链接的,可以加载和运行的可执行目标文件作为输出.输入的可重定位目标文件由各种不同的代码和数据节(section)组成,每一节都是一个连续的字节序列.指令在一节中,初始化了的全局变量在另一节中,而未初始化的变量又在另外一节中.  
 为了构造可执行文件,链接器必须完成两个主要任务.  
 **符号解析(symbol resolution)**.目标文件定义和引用符号.每个符号对应于一个函数,一个全局变量或一个静态变量.符号解析的目的是**将每个符号引用正好和一个符号定义关联起来**  
 **重定位(relocation)**.编译器和汇编器生成从地址0开始的代码和数据结构.**链接器通过把每个符号定义与一个内存位置关联起来,从而重定位这些节,然后修改所有对这些符号的引用,使得它们指向这个内存位置**.链接器使用汇编器产生的重定位条目(relocation entry)的详细指令,不加甄别地执行这样的重定位.  
##7.3 目标文件
 目标文件三种形式:  
 **可重定位目标文件**.包含二进制代码和数据,其形式可以在编译时与其他可重定位目标文件合并起来,创建一个可执行目标文件.  
 **可执行目标文件**.包含二进制代码和数据,其形式可以呗直接复制到内存并执行.  
 **共享目标文件**.一种特殊类型的可重定位目标文件,可以在加载或者运行时被动态地加载进内存并链接.  
 编译器和汇编器生成可重定位目标文件(包括共享目标文件).链接器生成可执行目标文件.一个**目标模块**就是一个字节序列,而一个**目标文件**就是一个以文件形式存放在磁盘中的目标模块.  
##7.4 可重定位目标文件  
 ELF头和节头部表之间的都是借.一个典型的ELF可重定位目标文件包含下面几个节:  
 <ul>
 <li>.text: 已编译程序的机器代码</li>
 <li>.rodata: 制度数据,比如printf语句中的格式串和开关语句的跳转表.</li>
 <li>.data: 已初始化的全局和静态C变量.局部C变量在运行时被保存在栈中,既不出现在.data节中,也不出现在.bss节中</li>
 <li>.bss: 未初始化的全局和静态C变量,以及所有被初始化为0的全局或静态变量.在目标文件中这个节不占据实际的空间,它仅仅是一个占位符.目标文件格式区分已初始化和未初始化变量时为了空间效率:在目标文件中,未初始化变量不需要占据任何实际的磁盘空间.运行时,在内存中分配这些变量,初始值位0.</li>
 <li>.symtab: 一个符号表,它存放在程序中定义和引用的函数和全局变量的信息.每个可重定位目标文件在.symtabl中都有一张符号表.然而,和编译器中的符号表不同,.symtab符号表不包含局部变量的条目.</li>
 <li>.rel.text: 一个.text节中位置的列表,当链接器把这个目标文件和其他文件组合时,需要修改这些位置.</li>
 <li>.real.data: 被模块引用或定义的所有全局变量的重定位信息.一般而言,任何已初始化的全局变量,如果他的初始值是一个全局变量地址后者外部定义函数的地址,都需要被修改.</li>
 <li>.debug: 一个调试符号表,其条目是程序中定义的局部变量和类型定义,程序中定义和引用的全局变量,以及原始的C源文件.</li>
 <li>.line: 原始C源程序中的行号和.text节中机器指令之间的映射.</li>  
 <li>.strtab: 一个字符串表,其内容包括.symtab 和 .debug节中的符号表,以及节头部中的节名字.字符串表就是以null结尾的字符串的序列.</li>
 </ul>
##7.5 符号和符号表
 每个可重定位目标模块m都有一个符号表,它包括m定义和引用的符号的信息.在链接器的上下文中,有三种不同的符号:  
 <ul>
 <li>由模块m定义并能被其他模块引用的全局符号.全局链接器符号对应于非静态的c函数和全局变量.</li>
 <li>由其他模块定义并被模块m引用的全局符号.这些符号称为外部符号,对应于在其他模块中定义的非静态C函数和全局变量.</li>
 <li>只被模块m定义和引用的局部符号.它们对应于带static属性的C函数和全局变量.</li>
 </ul>
 认识到本地连机器符号和本地程序变量不同是很重要的..symtab中的符号表**不包含对应于本地非静态程序变量的任何符号.**这些符号在运行时在栈中被管理,连机器对此类符号不感兴趣.  
 定义为带有C static属性的本地过程变量是不在栈中管理的.相反,编译器在.data或.bss中为每个定义分配空间,并在符号表中创建一个有唯一名字的本地链接器符号.比如,假设在同一模块中的两个函数工资定义了一个静态局部变量x:  
 ```
 int f()
 {
    static int x = 0;
    return x;
 }
 
 int g()
 {
     static int x = 1;
     return x;
 }
 ```
 在这种情况下,编译器向汇编器输出两个不同名字的局部链接器符号.比如,可以用x.1表示函数f中的定义,而用x.2表示函数g中的定义.  
 符号表是由汇编器构造的,使用编译器输出到汇编语言.s文件中的符号. .symtab节中包含ELF符号表.这张符号表包含一个条目的数组.格式如下:  
 ```
 typedef struct {
     int name;             /* String table offset */
     char type:4,          /* Function or data (4 bits) */
          binding:4;       /* Local or global (4 bits) */
     char reserved;        /* Unused*/
     short section;        /* Section header index */
     long value;           /* Section offset or absolute address */
     long size;            /* Object size in bytes */
 }Elf64_Symbol;         
 ```
 name是字符串中的字节偏移,指向符号的以null结尾的字符串名字.  
 value是符号的地址.对于可重定位目标来说,value是距定义目标的节的起始位置的偏移;对于可执行文件,就是绝对运行时地址.  
 size是目标的大小,以字节为单位.  
 type通常要么是数据,要么是函数.  
 符号表还包含各个节的条目,以及对应原始源文件的路径名的条目.所以这些目标的类型也有所不同.binding字段表示符号是本地的还是全局的.  
 每个符号都被分配到目标文件的某个节,由section字段表示,该字段也是一个到节头部表的索引.有三个特殊的伪节,它们在节头部表中是没有条目的:  
 ABS代表不该被重定位的符号;  
 UNDEF代表未定义的符号,也就是在本目标模块中引用,但是却在其他地方定义的符号;  
 COMMON表示还未被分配位置的未初始化的数据目标.  
 对于COMMON符号,value字段给出对齐要求,size给出最小的大小.注意,**只有可重定位目标中才有这些伪节,课执行目标文件中是没有的.**  
 现代的GCC版本根据以下规则来将可重定位目标文件中的符号分配到COMMON和.bss中:  
 COMMON 未初始化的全局变量  
 .bss 未初始化的静态变量,以及初始化为0的全局或静态变量.  
  
##7.6符号解析  
 链接器解析符号引用的方法是将每个引用于它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来.  
 不过,对全局符号的引用解析就棘手一些.当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时,会假设该符号是在其他某个模块中定义的,生成一个链接器符号表条目,并把它交给链接器处理.如果链接器在它的任何输入模块中都找不到这个被引用符号的定义,就会输出一条错误信息并终止.  
###7.6.1链接器如何解析多重定义的全局符号
 链接器的输入是**一组**可重定位目标模块.每个模块定义一组符号,有些是局部的(只对定义该符号的模块可见),有些事全局的.如果多个模块定义同名的全局符号,会发送什么呢?  
 编译时,编译器向汇编器输出每个全局符号,或是强或者是弱,而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里.  
 **函数和已初始化的全局变量是强符号,未初始化的全局变量是弱符号.**  
 根据强弱符号的定义,Linux链接器使用下面的规则来处理多重定义的符号名:  
 1: 不允许有多个同名的强符号.  
 2: 如果有一个强符号和多个弱符号同名,选择强符号.  
 3: 如果有多个弱符号同名,那么从这些弱符号任意选择一个.  
 **根据规则2和规则3的应用会造成一些不易察觉的运行时错误,比如下面的例子,其中x不幸的在一个模块中定义为int,而在另一个模块中定义为double.**  
 ```
 /* foo5.c */
 #include <stdio.h>
 void f(void);
 
 int y = 1512;
 int x =15213;
 
 int main()
 {
    f();
    printf("x = 0x%x y = 0x%x \n",x,y);
    return 0;
 }
 
 /* bar5.c */
 double x;
 void f()
 {
    x = -0.0;
 }
 ```
 在一台 x86-64 /Linux机器上,double类型是8个字节,而int类型是4个字节.在我们的系统中,x的地址是0x601024.因此,bar5.传递第六行中的复制 x=-0.0将用负零的**双精度浮点**表示覆盖内存中x和y的位置.  
 x = 0x0 y = 0x80000000  
 
