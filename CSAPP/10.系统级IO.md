#10.系统级I/O
 输入输出是在主存和外部设备(例如磁盘驱动器,终端和网络)之间复制数据的过程.输入操作是从I/O设备复制数据到主存,而输出操作是从主存复制数据到I/O设备.  
 所有语言的运行时系统都提供执行I/O的较高级别的工具.在Linux系统中,是通过使用由内核提供的系统级Unix I/O函数来实现这些高级别的I/O函数的.  
 + **了解UnixI/O将帮助你理解其他的系统概念**.I/O是系统操作不可或缺的一部分,因此,我们经常遇到I/O和其他系统概念之间的循环一来.例如,I/O在进程的创建和执行中扮演着关键的角色.反过来,进程创建又在不同进程间的文件共享中扮演着关键角色.因此,要真正理解I/O,必须理解进程,反之亦然.在对存储器层次结构,链接和加载,进程以及虚拟内存的讨论中,已经解除了I/O的某些方面.  
 + 有时除了使用Unix I/O意外别无选择.在某些重要的情况中,使用高级I/O函数不太可能,或者不太合适.例如,标准I/O库没有提供读取文件元数据的方式,例如文件大小或文件创建时间.另外,I/O库还存在一些问题,使得用它来进行网络编程非常冒险.  
  
  
##10.1 Unix I/O
 一个Linux文件就是一个m个字节的序列.**所有的I/O设备(例如网络,磁盘和终端)都被模型化为文件**,而所有的输入和输出都被当做对应文件的读和写来执行.这种将设备映射为文件的方式,允许Linux内核引用一个简单,低级的应用接口,称为Unix I/O,这使得所有的输入和输出都能以一种统一且一直的方式来执行.  
 + **打开文件**.一个应用程序通过要求内核打开相应的文件,来宣告它想要访问一个I/O设备.内核返回一个小的非负整数,叫做**描述符**,它在后续对此文件的所有操作中标志这个文件.内核记录有关这个打开文件的所有信息.应用程序只需记住这个描述符.
 + Linux shell创建的每个进程开始时都有三个打开的文件:**标准输入(描述符为0),标准输出(描述符为1)和标准错误(为2).**头文件 \<unistd.h\>定义了常亮STDIN_FILENO,STDOUT_FILENO和STDERR_FILENO,它们用来代替显式的描述符值.  
 + **改变当前的文件位置**.对于每个打开的文件,内核保持着一个文件位置k,初始为0.这个**文件位置是从文件开头起始的字节偏移量.**应用程序能够通过执行seek操作,显式地设置问加你的当前位置k.  
 + **读写文件**.一个读操作就是从文件复制n>0个字节到内存,从当前文件位置k开始,然后将k增加到k+n.给定一个大小为m字节的文件,当k>=m时执行度操作会出发一个称为**end-of-file(EOF)**的条件,应用程序能检测到这个条件.在文件结尾处并没有明确的EOF符号.  
 类似地,写操作就是从内存复制n>0个字节到一个文件,从当前文件位置k开始,然后更新k.  
 + **关闭文件.**当应用程序完成了对文件的访问之后,它就通知内核**关闭**这个文件.作为响应,内核释放文件打开时创建的数据结构,并将这个描述符恢复到可用的描述符池中.无论一个进程因为何种原因终止时,内核都会关闭所有打开的文件并释放它们的内存资源.  
  
  
##10.2 文件
 每个Linux文件都有一个类型(type)来表明它在系统中的角色:  
 + 普通文件(regular file)包含任意数据.应用程序常常要区分文本文件和二进制文件,文本文件是指含有ASCII或Unicode字符的普通文件;二进制文件是所有其他的文件.对内核而言,文本文件和二进制文件没有区别.  
 Linux文本文件包含了一个文本和(text line)序列,其中每一行都是一个字符序列,以一个新行符 \n结束.新行符与ASCII的换行符是一样的,其数字值为0x0a.  
 + 目录是包含一组链接的文件,其中每个链接都将一个文件名映射到一个文件,这个文件可能是另一个目录.每个目录至少含有两个条目:"."是到该目录自身的链接,以及".."是到目录层次结构中父目录的链接.  
 + 套接字是用来与另一个进程进行跨网络通信的文件.  
  
  
其他文件类型包含命名通道(name pipe),符号链接,以及字符和块设备,不在讨论范围内.  
 Linux内核将所有文件都组织成一个**目录层次结构**,由名为/(斜杠)的根目录确定.系统中每个文件都是根目录的直接或间接的后代.  
 作为其上下文的一部分,每个进程都有一个**当前工作目录**来确定其在目录层次结构中的当前位置.你可以用cd命令来修改shell中的当前工作目录.  
 目录层次结构中的位置用**路径名**来指定.路径名是一个字符串,包括一个可选斜杠,其后紧跟一系列的文件名,文件名之间用斜杠分隔.路径名有两种形式:  
 + **绝对路径名**以一个斜杠开始,表示从根节点开始的路径.  
 + **相对路径名**以文件名开始,表示从当前目录开始的路径.  
  
  
##10.3 打开和关闭文件
 进程是通过调用open函数来打开一个一村子啊的文件或者创建一个新文件的.  
 ```
 int open(char *filename, int flags, mode_t mode); 返回:弱成功则为新文件描述符,若出错为-1
 ```
 open函数将filename转换为一个文件描述符,并返回描述符数字.**返回的描述符总是在进程中当前没有打开的最小描述符.**  
 flags参数指明了进程打算如何访问这个文件.也可以是一个或更多位掩码的或,为谢提供给一些额外的指示.  
 mode参数指定了新文件的访问权限位.  
 进程通过调用close函数关闭一个打开的文件  
 ```
 int close(int fd);  返回:成功为0,出错为-1
 ```
##10.4 读和写文件
 应用程序是通过分别调用read和write函数来执行输入和输出的.  
 ```
 #include <unistd.h>
 
 ssize_t read(int fd, void *buf, size_t n);      返回:成功则为读的字节数,若EOF则为0,出错为-1
 
 ssize_t write(int fd, const void *buf, size_t n);  成功则为写的字节数, 出错为-1
 ```
 read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf.返回值-1表示一个错误,返回值0表示EOF.否则,返回表示的是实际传送的字节数量.  
 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置.  
 如下展示了一个程序使用read和write调用一次一个字节地从标准输入复制到标准输出.  
```
int main(void)
{
	char c;
	
	while(Read(STDIN_FILENO, &c, 1)!=0)
		Write(STDOUT_FILENO, &c, 1);
	exit(0);
}
```
 某些情况下,read和write传送的字节比应用程序要求的少.这些**不足值(short count)**不表示有错误.出现这样的情况的原因又:  
 + **读时遇到EOF**.假设准备读一个文件,该文件从当前文件位置开始只含有20多个字节,而我们以50个字节的片进行读取.这样一来,下一个read返回的不足值为20,此后的read将通过返回不足值0来发出EOF信号.
 + **从终端读文本行.**如果打开文件是与终端相关联的(如键盘和显示器),那么每个read函数将一次传送一个文本和,返回的不足值等于文本行的大小.
 + **读和写网络套接字(socket).**如果打开的文件对应于网络套接字,那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值.对Linux管道调用read和write时也有可能出现不足值,这种进程间通信机制不在讨论之内.(自己百度看看吧..)  
  
  
实际上除了EOF,在读磁盘文件时,将不会遇到不足值,而且在写磁盘文件时,也不会遇到不足值.  
##10.5 用RIO包健壮地读写 (这是书里自己写的一个包)
 此包是自己编写,学习一下处理方式就好.  
 RIO包提供了两类不同的函数:  
 + **无缓冲的输入输出函数.**这些函数直接在**内存和文件**之间传送数据,没有应用级缓冲,它们对将**二进制数据**读写到网络和从网络读写二进制数据尤其有用.  
 + **带缓冲的输入函数.**高效地从**文件中读取文本行和二进制数据**,这些文件的内容缓存在应用级缓冲区内,类似于为printf这样的标准I/O函数提供的缓冲区.带缓冲的RIO输入函数是线程安全的,它在同一个描述符上可以被交错地调用.例如,你可以从一个描述符中读一些文本行,然后读取一些二进制数据,接着再多读取一些文本行.  
  
  
###10.5.1 RIO的无缓冲的输入输出函数
 ```
 ssize_t rio_readn(int fd, void *usrbuf, size_t n);
 ssize_t rio_writen(int fd, void *usrbuf, size_t n);
 返回:成功则为传送的字节数,若EOF则为0(只对rio_readn而言),出错则为-1;
 ```
 **rio_readn**函数**从描述符fd的当前文件位置**最多传送n个字节**到内存位置usrbuf**.  
 类似地,**rio_writen**函数**从位置usrbuf**传送n个字节**到描述符fd**.  
 如果函数被一个应用信号处理程序的返回中断,那么每个函数都会手动地重启read或write.为了尽可能有较好的可移植性,我们允许被中断的系统调用,在必要时重启它们.  
```
//size_t 和 ssize_t是两种类型   范围不同 分别是 size_t 为 unsigned long. 另一个是 long
//usrbuf是一个内存位置,此函数没有缓冲.

ssize_t rio_readn(int fd, void *usrbuf, size_t n)
{
	size_t nleft = n;
	ssize_t nread;
	char *bufp = usrbuf;
	
	while(nleft > 0) {
		if((nread = read(fd,bufp,nleft)) < 0) {
			if (errno == EINTR) /* Interrupted by sig handler return */
				nread = 0;		/* and call read() again */
			else 
				return -1;		/* errno set by read() */
		}
		else if (nread ==0)
			break;				/* EOF */
		nleft -= nread;			/* 若nread 为0,则 nleft不变,继续重复循环
		bufp += nread;
	}
	return (n - nleft);			/* Return >= 0 */
}

ssize_t rio_writen(int fd, void *usrbuf, size_t n)
{
	size_t nleft = n;
	ssize_t nwritten;
	char *bufp = usrbuf;
	while(nleft > 0) {
		if ((nwritten = write(fd, bufp, nleft)) <= 0) {
			if (errno == EINTR) /* Interrupted by sig handler return */
				nwritten = 0;	/* and call write() again */
			else
				return -1		/* errno set by write() */
		}
		nleft -= nwritten;
		bufp += nwritten;
	}
	return n;
}
```
###10.5.2 RIO的带缓冲的输入函数
 
